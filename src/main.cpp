#include <filesystem>
#include <iostream>
#include <vector>
#include <string>
#include <ctime>
#include <chrono>

#include <data.hpp>
#include <model.hpp>

struct Args
{
    // Default values
    bool verbose = false;
    bool train = false;
    bool predictFile = false;
    std::string predictFilePath = "";
    std::string outputFilePath = "";
    bool produceReport = false;

    int numberOfTrees = 10;
    int maxDepth = 5;
    int maxFeatures = 1;
};

struct Report
{
    std::string fileName;
    std::string fileSize;
    std::string fileType;
    std::string prediction;
    std::string confidence;
    std::string handlingRecommendation;
    std::string timeOfAnalysis;
    std::vector<std::pair<std::string, double>> fileFeatures;
};

void trainRandomForestModel(int numberOfTrees, int maxDepth, int maxFeatures, bool verbose = false)
{
    std::vector<std::vector<double>> allFeatures, trainFeatures, testFeatures;
    std::vector<int> allLabels, trainLabels, testLabels;
    std::vector<std::string> allHeaders;

    auto startData = std::chrono::high_resolution_clock::now();

    for (auto &csvPath : {"./inc/benignData.csv", "./inc/malwareData.csv"})
    {
        if (!loadCSV(csvPath, allFeatures, allLabels, allHeaders, "Malware", {"Code"}))
        {
            std::cerr << "Failed to load CSV file!" << std::endl;
            return;
        }
    }

    if (verbose)
    {
        auto endData = std::chrono::high_resolution_clock::now();
        std::chrono::duration<double, std::milli> elapsed = endData - startData;
        std::cout << "Loaded " << allFeatures.size() << " total data points in " << elapsed.count() << " ms" << std::endl;
    }

    trainTestSplit(
        allFeatures, allLabels, trainFeatures,
        trainLabels, testFeatures, testLabels);

    auto begin = std::chrono::high_resolution_clock::now();

    RandomForest forest(numberOfTrees, maxDepth, maxFeatures);
    forest.train(trainFeatures, trainLabels);

    auto end = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double, std::milli> elapsed = end - begin;

    if (verbose)
    {
        std::cout << "Training completed in " << elapsed.count() << " ms" << std::endl;
        std::cout << "Estimated accuracy: " << forest.calculateAccuracy(testFeatures, testLabels) << std::endl;
    }

    forest.saveModel("./inc/model.bin");

    if (verbose)
    {
        std::cout << "Model saved successfully" << std::endl;
    }
}

void helpOutput(std::string program)
{
    int width = 40;

    std::cout << "Usage: " << std::endl;
    std::cout << "  " << program << " [options] <command> [<args>...]" << std::endl;

    std::cout << "\nOptions:" << std::endl;
    std::cout << std::left << std::setw(width) << "  -h, --help"
              << "Display this help message" << std::endl;
    std::cout << std::left << std::setw(width) << "  -v, --verbose"
              << "Enable verbose output" << std::endl;

    std::cout << "\nCommands:" << std::endl;
    std::cout << std::left << std::setw(width) << "  train [trees] [depth] [features]"
              << "Train a new model, use no arguments for default values" << std::endl;
    std::cout << std::left << std::setw(width) << "  predict <predictFile> [outputFile]"
              << "Predict the label of a file" << std::endl;
    std::cout << std::left << std::setw(width) << "  report <predictFile> [outputFile]"
              << "Generate a report for a file" << std::endl;

    std::cout << "\nExamples:" << std::endl;
    std::cout << "  To train a model with custom values:" << std::endl;
    std::cout << "  $ " << program << " train --trees 100 --depth 10 --features 5" << std::endl;
    std::cout << "\n  To predict the label of a file:" << std::endl;
    std::cout << "  $ " << program << " predict --file path/to/input_file.exe --output path/to/output_file.txt" << std::endl;
    std::cout << "\n  To generate a report for a file:" << std::endl;
    std::cout << "  $ " << program << " report --file path/to/input_file.exe --output path/to/output_file.txt" << std::endl;
}

Args parseArguments(int argCount, char *args[])
{
    Args parsedArgs;
    std::string program = args[0];

    std::map<std::string, std::function<void(std::string)>> argActions = {
        {"-h", [&](std::string)
         { helpOutput(program); exit(0); }},
        {"--help", [&](std::string)
         { helpOutput(program); exit(0); }},
        {"-v", [&](std::string)
         { parsedArgs.verbose = true; }},
        {"--verbose", [&](std::string)
         { parsedArgs.verbose = true; }},
        {"train", [&](std::string)
         { parsedArgs.train = true; }},
        {"--trees", [&](std::string val)
         { parsedArgs.numberOfTrees = std::stoi(val); }},
        {"--depth", [&](std::string val)
         { parsedArgs.maxDepth = std::stoi(val); }},
        {"--features", [&](std::string val)
         { parsedArgs.maxFeatures = std::stoi(val); }},
        {"predict", [&](std::string)
         { parsedArgs.predictFile = true; }},
        {"report", [&](std::string)
         { parsedArgs.produceReport = true; }},
        {"--file", [&](std::string val)
         {
             parsedArgs.predictFilePath = val;
             if (!std::filesystem::is_regular_file(parsedArgs.predictFilePath))
             {
                 std::cerr << "Error: Invalid file path provided for prediction." << std::endl;
                 exit(1);
             }
         }},
        {"--output", [&](std::string val)
         { parsedArgs.outputFilePath = val; }}};

    for (int i = 1; i < argCount; i++)
    {
        std::string arg = args[i];
        if (argActions.count(arg))
        {
            argActions[arg](i + 1 < argCount ? args[i + 1] : "");
            i += argActions[arg](i + 1 < argCount ? args[i + 1] : "") != "";
        }
    }

    // If both -r and -p are provided, -p is ignored
    if (parsedArgs.produceReport && parsedArgs.predictFile)
    {
        parsedArgs.predictFile = false;
    }

    // Check that path was provided for prediction
    if ((parsedArgs.predictFile || parsedArgs.produceReport) && parsedArgs.predictFilePath.empty())
    {
        std::cerr << "Error: No file path provided for prediction." << std::endl;
        return Args();
    }

    return parsedArgs;
}

void writeSectionToReport(std::ostream &reportStream, const std::string &title, const std::map<std::string, std::string> &data)
{
    reportStream << title << std::endl;
    for (const auto &[key, value] : data)
    {
        reportStream << "- " << key << ": " << value << std::endl;
    }
    reportStream << std::endl;
}

void writeFileFeatures(std::ostream &reportStream, const std::map<std::string, std::string> &features)
{
    reportStream << "File Features:" << std::endl;
    reportStream << "|--------------------------------|-----------------|" << std::endl;
    reportStream << "| Feature Name                   | Value           |" << std::endl;
    reportStream << "|--------------------------------|-----------------|" << std::endl;
    for (const auto &[key, value] : features)
    {
        reportStream << "| " << std::left << std::setw(30) << key << " | " << std::right << std::setw(15)
                     << value << " |" << std::endl;
    }
    reportStream << "|--------------------------------|-----------------|" << std::endl;
    reportStream << std::endl;
}

std : stringstream generateReportStream(std::stringstream &reportStream, const Report &report)
{

    // File Analysis Report
    reportStream << "File Analysis Report" << std::endl;
    reportStream << "--------------------" << std::endl;

    // File Information
    writeSectionToReport(reportStream, "File Information", {{"File Name", report.fileName}, {"File Size", std::to_string(report.fileSize) + " bytes"}, {"File Type", report.fileType}});

    // Prediction and Confidence
    writeSectionToReport(reportStream, "Prediction and Confidence", {{"Prediction", report.prediction}, {"Confidence", std::to_string(report.confidence) + "%"}});

    // File Handling Recommendations
    writeSectionToReport(reportStream, "File Handling Recommendations", {{"", report.handlingRecommendation}});

    // File Features
    writeFileFeatures(reportStream, report.fileFeatures);

    // Conclusion
    writeSectionToReport(reportStream, "Conclusion", {{"File " + report.fileName + " is likely ", report.prediction + ", with " + std::to_string(report.confidence) + "% confidence"}, {"", report.handlingRecommendation}});

    // Report generated timestamp
    reportStream << std::endl;
    reportStream << "Report generated on: " << report.timeOfAnalysis << std::endl;

    return reportStream;
}

int main(int argCount, char *args[])
{
    Args parsedArgs = parseArguments(argCount, args); // Check arguments

    if (parsedArgs.train)
    {
        trainRandomForestModel(
            parsedArgs.numberOfTrees, parsedArgs.maxDepth,
            parsedArgs.maxFeatures, parsedArgs.verbose);
    }

    Report report;
    std::stringstream reportStream;

    if (parsedArgs.predictFile || parsedArgs.produceReport)
    {
        report = generateFileReport(parsedArgs.predictFilePath);
    }

    if (parsedArgs.produceReport)
    {
        reportStream = generateReportStream(reportStream, report);
    }

    if (parsedArgs.predictFile)
    {
        writeSectionToReport(reportStream, "Prediction and Confidence", {{"Prediction", report.prediction}, {"Confidence", std::to_string(report.confidence) + "%"}});
    }

    std::cout << reportStream.str(); // Print the report to the console

    // Save the report to a file
    if (!parsedArgs.outputFilePath.empty())
    {
        std::ofstream outputFile(parsedArgs.outputFilePath);
        outputFile << reportStream.str();
        outputFile.close();
    }

    return 0;
}
