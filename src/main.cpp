#include <filesystem>
#include <iostream>
#include <vector>
#include <string>
#include <ctime>

#include <data.hpp>
#include <model.hpp>

struct Args {
    bool verbose = false;
    bool train = false;
    bool predictFile = false;
    std::string filePathToPredict;
    bool produceReport = false;

    int numberOfTrees = 10;
    int maxDepth = 5;
    int maxFeatures = 1;
};

struct Report {
    std::string fileName;
    std::string fileSize;
    std::string fileType;
    std::string prediction;
    std::string confidence;
    std::string handlingRecommendation;
    std::string timeOfAnalysis;
    std::vector<std::pair<std::string, double>> fileFeatures;
};

void trainRandomForestModel(int numberOfTrees, int maxDepth, int maxFeatures, bool verbose = false) {
    std::vector<std::vector<double>> allFeatures, trainFeatures, testFeatures;
    std::vector<int> allLabels, trainLabels, testLabels;
    std::vector<std::string> allHeaders;

    // Load data from CSV file
    for (auto& csvPath : std::filesystem::directory_iterator("./inc/malware")) {
        if (!loadCSV(csvPath.path().string(), allFeatures, allLabels, allHeaders, "Malware", {"Code"})) {
            std::cerr << "Failed to load CSV file!" << std::endl;
            return;
        }
    }

    if (verbose) {
        std::cout << "Loaded " << allFeatures.size() << " total data points" << std::endl;
    }

    // Split data into train and test sets
    trainTestSplit(allFeatures, allLabels, trainFeatures, trainLabels, testFeatures, testLabels);

    // Training features and labels MUST be sorted
    sortData(trainFeatures, trainLabels);

    clock_t begin = clock();

    RandomForest forest(numberOfTrees, maxDepth, maxFeatures);
    forest.train(trainFeatures, trainLabels);

    clock_t end = clock();
    double elapsed_ms = double(end - begin) / CLOCKS_PER_SEC * 1000.0;

    if (verbose) {
        std::cout << "Training completed in " << elapsed_ms << " ms" << std::endl;
    }

    // Evaluate the accuracy of the model
    double accuracy = forest.calculateAccuracy(testFeatures, testLabels);

    if (verbose) {
        std::cout << "Estimated accuracy: " << accuracy << std::endl;
    }

    // Save the model to a file
    forest.saveModel("./inc/model.bin");

    if (verbose) {
        std::cout << "Model saved successfully" << std::endl;
    }
}

void helpOutput(std::string program) {
    int width = 40;

    std::cout << "Usage: " << program << " [options]" << std::endl;
    std::cout << "Options:" << std::endl;
    std::cout << std::left << std::setw(width) << "  -h, -help" << "Display this help message" << std::endl;
    std::cout << std::left << std::setw(width) << "  -v, -verbose" << "Enable verbose output" << std::endl;
    std::cout << std::left << std::setw(width) << "  -t, -train <trees> <depth> <features>" << "Train a new model, use no arguments for default values" << std::endl;
    std::cout << std::left << std::setw(width) << "  -p, -predict <file>" << "Predict the label of a file" << std::endl;
    std::cout << std::left << std::setw(width) << "  -r, -report <file>" << "Generate a report for a file" << std::endl;
}

Args parseArguments(int argCount, char* args[]) {
    Args parsedArgs;
    std::string program = args[0];
    bool invalidArgs = false;

    if (argCount == 1) {
        helpOutput(program);
        return parsedArgs;
    }

    for (int i = 1; i < argCount; i++) {
        std::string arg = args[i];

        // Check for help flag
        if (arg == "-h" || arg == "-help") {
            helpOutput(program);
            break;
        }

        // Check for verbose flag
        if (arg == "-v" || arg == "-verbose") {
            parsedArgs.verbose = true;
            continue;
        }

        // Check for train flag
        if (arg == "-t" || arg == "-train") {
            parsedArgs.train = true;

            // Get the training parameters
            if (i + 3 < argCount) {
                try {
                    parsedArgs.numberOfTrees = std::stoi(args[++i]);
                    parsedArgs.maxDepth = std::stoi(args[++i]);
                    parsedArgs.maxFeatures = std::stoi(args[++i]);
                } catch (const std::exception& e) {
                    std::cerr << "Error: Invalid training parameters provided." << std::endl;
                    invalidArgs = true;
                }
            } else {
                std::cout << "No arguments for training, using default values" << std::endl;
            }
            continue;
        }

        // Check for predict flag
        if (arg == "-p" || arg == "-predict") {
            parsedArgs.predictFile = true;
            // Get current path and append the file name to it
            std::string currentPath = std::filesystem::current_path().string() + "\\";
            parsedArgs.filePathToPredict = currentPath + args[++i];
            if (!std::filesystem::is_regular_file(parsedArgs.filePathToPredict)) {
                std::cerr << "Error: Invalid file path provided for prediction." << std::endl;
                invalidArgs = true;
            }
            continue;
        }

        // Check for report flag
        if (arg == "-r" || arg == "-report") {
            parsedArgs.produceReport = true;
            parsedArgs.filePathToPredict = args[++i];
            continue;
        }

        // If an invalid argument is provided, exit
        if (invalidArgs) {
            return Args();
        }
    }

    // If both -r and -p are provided, -p is ignored
    if (parsedArgs.produceReport == 1 && parsedArgs.predictFile == 1) {
        parsedArgs.predictFile = false;
    }

    return parsedArgs;
}

Report generateFileReport(const std::string& filePath) {
    Report report;

    // File Information
    report.fileName = std::filesystem::path(filePath).filename().string();
    report.fileSize = std::to_string(std::filesystem::file_size(filePath));
    report.fileType = std::filesystem::path(filePath).extension().string();

    // Load the model from ./inc/model.bin
    RandomForest forest("./inc/model.bin");

    // Get features from a single file
    std::vector<std::string> headers;
    std::vector<double> features;

    fileAttr(filePath, headers, features);

    // Evaluate the accuracy of the model
    report.prediction = (forest.predict(features) == 1 ? "Malware" : "Benign");
    report.confidence = std::to_string(forest.confidence(features));

    // handlingRecommendation
    if (report.prediction == "Malware") {
        report.handlingRecommendation = "Handle with care, delete if possible, otherwise consider quarantining and running in a sandbox environment";
    }
    else {
        report.handlingRecommendation = "No action required, however, remain vigilant and monitor for any suspicious activity";
    }

    // File Features
    for (int i = 0; i < headers.size(); i++) {
        report.fileFeatures.push_back({ headers[i], features[i] });
    }

    // Time of Analysis
    std::time_t currentTime = std::time(nullptr);
    std::stringstream timeStream;
    timeStream << std::put_time(std::localtime(&currentTime), "%Y-%m-%d %H:%M:%S");
    report.timeOfAnalysis = timeStream.str();

    return report;
}

int main(int argCount, char* args[]) {

    // User interaction
    // Command line argument testing below

    // Check arguments
    Args parsedArgs = parseArguments(argCount, args);

    // Train the model to ./inc/model.bin
    if (parsedArgs.train) {
        trainRandomForestModel(parsedArgs.numberOfTrees, parsedArgs.maxDepth, parsedArgs.maxFeatures, parsedArgs.verbose);
    }

    Report report;
    std::stringstream reportStream;

    if (parsedArgs.predictFile || parsedArgs.produceReport) {
        report = generateFileReport(parsedArgs.filePathToPredict);
    }

    if (parsedArgs.produceReport) {
        // File Analysis Report
        reportStream << "File Analysis Report" << std::endl;
        reportStream << "--------------------" << std::endl;

        // File Information
        reportStream << "File Information:" << std::endl;
        reportStream << "- File Name: " << report.fileName << std::endl;
        reportStream << "- File Size: " << report.fileSize << " bytes" << std::endl;
        reportStream << "- File Type: " << report.fileType << std::endl;
        reportStream << std::endl;

        // Prediction and Confidence
        reportStream << "Prediction and Confidence:" << std::endl;
        reportStream << "- Prediction: " << report.prediction << std::endl;
        reportStream << "- Confidence: " << std::fixed << std::setprecision(1) << report.confidence << "%" << std::endl;
        reportStream << std::endl;

        // File Handling Recommendations
        reportStream << "File Handling Recommendations:" << std::endl;
        reportStream << "- " << report.handlingRecommendation << std::endl;
        reportStream << std::endl;

        // File Features
        reportStream << "File Features:" << std::endl;
        reportStream << "|--------------------------------|-----------------|" << std::endl;
        reportStream << "| Feature Name                   | Value           |" << std::endl;
        reportStream << "|--------------------------------|-----------------|" << std::endl;
        for (auto& feature : report.fileFeatures) {
            reportStream << "| " << std::left << std::setw(30) << feature.first << " | " << std::right << std::setw(15)
                         << feature.second << " |" << std::endl;
        }
        reportStream << "|--------------------------------|-----------------|" << std::endl;
        reportStream << std::endl;

        // Conclusion
        reportStream << "Conclusion:" << std::endl;
        reportStream << "- File " << parsedArgs.filePathToPredict << " is likely " << report.prediction << ", with a " << report.confidence << "% confidence" << std::endl;
        reportStream << "- " << report.handlingRecommendation << std::endl;

        // Report generated timestamp
        reportStream << std::endl;
        reportStream << "Report generated on: " << report.timeOfAnalysis << std::endl;
    }

    if (parsedArgs.predictFile) {
        // Prediction and Confidence
        reportStream << "Prediction and Confidence:" << std::endl;
        reportStream << "- Prediction: " << report.prediction << std::endl;
        reportStream << "- Confidence: " << std::fixed << std::setprecision(1) << report.confidence << "%" << std::endl;
        reportStream << std::endl;
    }

    // Print the report to the console
    std::cout << reportStream.str();

    return 0;
}