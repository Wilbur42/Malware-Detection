#include <filesystem>
#include <iostream>
#include <vector>
#include <string>
#include <chrono>

#include <data.hpp>
#include <model.hpp>

struct Args
{
    // Default values
    bool verbose = false;
    bool train = false;
    bool predictFile = false;
    std::string predictFilePath = "";
    std::string outputFilePath = "";
    bool produceReport = false;

    int numberOfTrees = 10;
    int maxDepth = 5;
    int maxFeatures = 1;
};

struct Report
{
    std::string fileName;
    std::string fileSize;
    std::string fileType;
    std::string prediction;
    std::string confidence;
    std::string handlingRecommendation;
    std::string timeOfAnalysis;
    std::vector<std::pair<std::string, double>> fileFeatures;
};

void trainRandomForestModel(int numberOfTrees, int maxDepth, int maxFeatures, bool verbose = false)
{
    std::vector<std::vector<double>> allFeatures, trainFeatures, testFeatures;
    std::vector<int> allLabels, trainLabels, testLabels;
    std::vector<std::string> allHeaders;

    if (verbose)
    {
        std::cout << "Loading data..." << std::endl;
    }

    auto start = std::chrono::high_resolution_clock::now();

    // Load data from CSV file
    for (auto &csvPath : {"./inc/benignData.csv", "./inc/malwareData.csv"})
    {
        std::cout << "Loading " << csvPath << std::endl;
        if (!loadCSV(csvPath, allFeatures, allLabels, allHeaders, "Malware", {"Code"}))
        {
            std::cerr << "Failed to load CSV file!" << std::endl;
            return;
        }
    }

    if (verbose)
    {
        auto end = std::chrono::high_resolution_clock::now();
        std::chrono::duration<double> elapsed = end - start;
        std::cout << "Loaded " << allFeatures.size() << " total data points in " << double(elapsed.count()) / CLOCKS_PER_SEC * 1000.0 << " ms" << std::endl;
    }

    // Split data into train and test sets
    trainTestSplit(allFeatures, allLabels, trainFeatures, trainLabels, testFeatures, testLabels);

    clock_t begin = clock();

    RandomForest forest(numberOfTrees, maxDepth, maxFeatures);
    forest.train(trainFeatures, trainLabels);

    clock_t end = clock();
    double elapsed_ms = double(end - begin) / CLOCKS_PER_SEC * 1000.0;

    if (verbose)
    {
        std::cout << "Training completed in " << elapsed_ms << " ms" << std::endl;
    }

    // Evaluate the accuracy of the model
    double accuracy = forest.calculateAccuracy(testFeatures, testLabels);

    if (verbose)
    {
        std::cout << "Estimated accuracy: " << accuracy << std::endl;
    }

    // Save the model to a file
    forest.saveModel("./inc/model.bin");

    if (verbose)
    {
        std::cout << "Model saved successfully" << std::endl;
    }
}

void helpOutput(std::string program)
{
    int width = 40;

    std::cout << "Usage: " << std::endl;
    std::cout << "  " << program << " [options] <command> [<args>...]" << std::endl;

    std::cout << "\nOptions:" << std::endl;
    std::cout << std::left << std::setw(width) << "  -h, --help"
              << "Display this help message" << std::endl;
    std::cout << std::left << std::setw(width) << "  -v, --verbose"
              << "Enable verbose output" << std::endl;

    std::cout << "\nCommands:" << std::endl;
    std::cout << std::left << std::setw(width) << "  train [trees] [depth] [features]"
              << "Train a new model, use no arguments for default values" << std::endl;
    std::cout << std::left << std::setw(width) << "  predict <predictFile> [outputFile]"
              << "Predict the label of a file" << std::endl;
    std::cout << std::left << std::setw(width) << "  report <predictFile> [outputFile]"
              << "Generate a report for a file" << std::endl;

    std::cout << "\nExamples:" << std::endl;
    std::cout << "  To train a model with custom values:" << std::endl;
    std::cout << "  $ " << program << " train --trees 100 --depth 10 --features 5" << std::endl;
    std::cout << "\n  To predict the label of a file:" << std::endl;
    std::cout << "  $ " << program << " predict --file path/to/input_file.exe --output path/to/output_file.txt" << std::endl;
    std::cout << "\n  To generate a report for a file:" << std::endl;
    std::cout << "  $ " << program << " report --file path/to/input_file.exe --output path/to/output_file.txt" << std::endl;
}

Args parseArguments(int argCount, char *args[])
{
    Args parsedArgs;
    std::string program = args[0];

    if (argCount == 1)
    {
        helpOutput(program);
        return parsedArgs;
    }

    for (int i = 1; i < argCount; i++)
    {
        std::string arg = args[i];

        // Check for help flag
        if (arg == "-h" || arg == "--help")
        {
            helpOutput(program);
            return Args();
        }

        // Check for verbose flag
        if (arg == "-v" || arg == "--verbose")
        {
            parsedArgs.verbose = true;
            continue;
        }

        // Check for train flag
        if (arg == "train")
        {
            parsedArgs.train = true;
            continue;
        }

        // Check for training arguments
        if (parsedArgs.train)
        {
            // Check for number of trees
            if (arg == "--trees")
            {
                parsedArgs.numberOfTrees = std::stoi(args[++i]);
                continue;
            }

            // Check for max depth
            if (arg == "--depth")
            {
                parsedArgs.maxDepth = std::stoi(args[++i]);
                continue;
            }

            // Check for max features
            if (arg == "--features")
            {
                parsedArgs.maxFeatures = std::stoi(args[++i]);
                continue;
            }
        }

        // Check for predict flag
        if (arg == "predict")
        {
            parsedArgs.predictFile = true;
            continue;
        }

        // Check for report flag
        if (arg == "report")
        {
            parsedArgs.produceReport = true;
            continue;
        }

        // Check for file path
        if (parsedArgs.predictFile || parsedArgs.produceReport)
        {
            if (arg == "--file")
            {
                parsedArgs.predictFilePath = args[++i];
                if (!std::filesystem::is_regular_file(parsedArgs.predictFilePath))
                {
                    std::cerr << "Error: Invalid file path provided for prediction." << std::endl;
                    return Args();
                }
                continue;
            }
            else if (arg == "--output")
            {
                parsedArgs.outputFilePath = args[++i];
                continue;
            }
        }
    }

    // If both -r and -p are provided, -p is ignored
    if (parsedArgs.produceReport == 1 && parsedArgs.predictFile == 1)
    {
        parsedArgs.predictFile = false;
    }

    // Check that path was provided for prediction
    if ((parsedArgs.predictFile || parsedArgs.produceReport) && parsedArgs.predictFilePath.empty())
    {
        std::cerr << "Error: No file path provided for prediction." << std::endl;
        return Args();
    }

    return parsedArgs;
}

Report generateFileReport(const std::string &filePath)
{
    Report report;

    // File Information
    report.fileName = std::filesystem::path(filePath).filename().string();
    report.fileSize = std::to_string(std::filesystem::file_size(filePath));
    report.fileType = std::filesystem::path(filePath).extension().string();

    // Load the model from ./inc/model.bin
    RandomForest forest("./inc/model.bin");

    // Get features from a single file
    std::vector<std::string> headers;
    std::vector<double> features;

    fileAttr(filePath, headers, features);

    // Evaluate the accuracy of the model
    int prediction = forest.predict(features);
    report.prediction = (prediction == 1) ? "Malware" : (prediction == 0) ? "Benign"
                                                    : (prediction == -1)  ? "Inconclusive"
                                                                          : "Unknown";
    report.confidence = std::to_string(forest.confidence(features));

    // handlingRecommendation
    if (report.prediction == "Malware")
    {
        report.handlingRecommendation = "Handle with care, delete if possible, otherwise consider quarantining and running in a sandbox environment";
    }
    else if (report.prediction == "Benign")
    {
        report.handlingRecommendation = "No action required, however, remain vigilant and monitor for any suspicious activity";
    }
    else
    {
        report.handlingRecommendation = "Act cautiously, remain vigilant and monitor for any suspicious activity";
    }

    // File Features
    for (int i = 0; i < headers.size(); i++)
    {
        report.fileFeatures.push_back({headers[i], features[i]});
    }

    // Time of Analysis
    std::time_t currentTime = std::time(nullptr);
    std::stringstream timeStream;
    timeStream << std::put_time(std::localtime(&currentTime), "%Y-%m-%d %H:%M:%S");
    report.timeOfAnalysis = timeStream.str();

    return report;
}

int main(int argCount, char *args[])
{

    // Check arguments
    Args parsedArgs = parseArguments(argCount, args);

    // Train the model to ./inc/model.bin
    if (parsedArgs.train)
    {
        trainRandomForestModel(parsedArgs.numberOfTrees, parsedArgs.maxDepth, parsedArgs.maxFeatures, parsedArgs.verbose);
    }

    Report report;
    std::stringstream reportStream;

    if (parsedArgs.predictFile || parsedArgs.produceReport)
    {
        report = generateFileReport(parsedArgs.predictFilePath);
    }

    if (parsedArgs.produceReport)
    {
        // File Analysis Report
        reportStream << "File Analysis Report" << std::endl;
        reportStream << "--------------------" << std::endl;

        // File Information
        reportStream << "File Information:" << std::endl;
        reportStream << "- File Name: " << report.fileName << std::endl;
        reportStream << "- File Size: " << report.fileSize << " bytes" << std::endl;
        reportStream << "- File Type: " << report.fileType << std::endl;
        reportStream << std::endl;

        // Prediction and Confidence
        reportStream << "Prediction and Confidence:" << std::endl;
        reportStream << "- Prediction: " << report.prediction << std::endl;
        reportStream << "- Confidence: " << std::fixed << std::setprecision(1) << report.confidence << "%" << std::endl;
        reportStream << std::endl;

        // File Handling Recommendations
        reportStream << "File Handling Recommendations:" << std::endl;
        reportStream << "- " << report.handlingRecommendation << std::endl;
        reportStream << std::endl;

        // File Features
        reportStream << "File Features:" << std::endl;
        reportStream << "|--------------------------------|-----------------|" << std::endl;
        reportStream << "| Feature Name                   | Value           |" << std::endl;
        reportStream << "|--------------------------------|-----------------|" << std::endl;
        for (auto &feature : report.fileFeatures)
        {
            reportStream << "| " << std::left << std::setw(30) << feature.first << " | " << std::right << std::setw(15)
                         << feature.second << " |" << std::endl;
        }
        reportStream << "|--------------------------------|-----------------|" << std::endl;
        reportStream << std::endl;

        // Conclusion
        reportStream << "Conclusion:" << std::endl;
        reportStream << "- File " << parsedArgs.predictFilePath << " is likely " << report.prediction << ", with " << report.confidence << "% confidence" << std::endl;
        reportStream << "- " << report.handlingRecommendation << std::endl;

        // Report generated timestamp
        reportStream << std::endl;
        reportStream << "Report generated on: " << report.timeOfAnalysis << std::endl;
    }

    if (parsedArgs.predictFile)
    {
        // Prediction and Confidence
        reportStream << "Prediction and Confidence:" << std::endl;
        reportStream << "- Prediction: " << report.prediction << std::endl;
        reportStream << "- Confidence: " << std::fixed << std::setprecision(1) << report.confidence << "%" << std::endl;
        reportStream << std::endl;
    }

    // Print the report to the console
    std::cout << reportStream.str();

    // Save the report to a file
    if (parsedArgs.outputFilePath != "")
    {
        std::ofstream outputFile(parsedArgs.outputFilePath);
        outputFile << reportStream.str();
        outputFile.close();
    }

    return 0;
}