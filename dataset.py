import hashlib
import random
import json
import os

from pefile import PE, PEFormatError
from numpy import mean

## Change the below variables as necessary ##

BENIGN_FILE_PATHS = ['C:\\', 'D:\\'] # Sourced from local machine

MALWARE_FILE_PATHS = [ # Sourced from VirusShare (https://virusshare.com/)
    'E:\\VirusShare_00459',
    'E:\\VirusShare_00460',
    'E:\\VirusShare_00461',
    'E:\\VirusShare_00462',
    'E:\\VirusShare_00463',
    'E:\\VirusShare_00464',
    'E:\\VirusShare_00465',
    'E:\\VirusShare_00466',
]

# Junctions and folders to ignore when traversing file system
IGNORED_FOLDERS = [
    '$Recycle.Bin',
    'Documents and Settings',
    'Application Data',
    'Cookies',
    'Local Settings',
    'NetHood',
    'PrintHood',
    'Recent',
    'SendTo',
    'Start Menu',
    'Templates',
    'Temporary Internet Files',

    # My additions
    '_Coding',
]

## End of variables ##

def get_attributes(file_path, malware=1):
    try:
        pe = PE(file_path)
    except PEFormatError:
        print('Not a PE file')
        return {}

    arr = {'Name': os.path.basename(file_path), 'Malware': malware}

    dos_header_attrs = [
        'e_magic', 'e_cblp', 'e_cp', 'e_crlc', 'e_cparhdr', 'e_minalloc', 'e_maxalloc',
        'e_ss', 'e_sp', 'e_csum', 'e_ip', 'e_cs', 'e_lfarlc', 'e_ovno', 'e_oemid',
        'e_oeminfo', 'e_lfanew'
    ]
    dos_header_data = {attr: getattr(pe.DOS_HEADER, attr, 0) for attr in dos_header_attrs}
    arr.update(dos_header_data)

    # Removed Signature as it is used to identify PE files
    # And we already know that this is a PE file since it passed the PEFormatError check

    dos_header_attrs = [
        'e_magic', 'e_cblp', 'e_cp', 'e_crlc', 'e_cparhdr', 'e_minalloc', 'e_maxalloc',
        'e_ss', 'e_sp', 'e_csum', 'e_ip', 'e_cs', 'e_lfarlc', 'e_ovno', 'e_oemid',
        'e_oeminfo', 'e_lfanew'
    ]
    dos_header_data = {attr: getattr(pe.DOS_HEADER, attr, 0) for attr in dos_header_attrs}
    arr.update(dos_header_data)

    optional_header_attrs = [
        'Magic', 'MajorLinkerVersion', 'MinorLinkerVersion', 'SizeOfCode', 'SizeOfInitializedData',
        'SizeOfUninitializedData', 'AddressOfEntryPoint', 'BaseOfCode', 'ImageBase',
        'SectionAlignment', 'FileAlignment', 'MajorOperatingSystemVersion',
        'MinorOperatingSystemVersion', 'MajorImageVersion', 'MinorImageVersion',
        'MajorSubsystemVersion', 'MinorSubsystemVersion', 'SizeOfImage', 'SizeOfHeaders',
        'CheckSum', 'Subsystem', 'SizeOfStackReserve', 'SizeOfStackCommit', 'SizeOfHeapReserve',
        'SizeOfHeapCommit', 'LoaderFlags', 'NumberOfRvaAndSizes', 'DllCharacteristics'
    ]
    optional_header_data = {attr: getattr(pe.OPTIONAL_HEADER, attr, 0) for attr in optional_header_attrs}
    arr.update(optional_header_data)

    # Removed Data Directory as Values not loading
    # As well as not currently being used, may add back later

    if hasattr(pe, 'DIRECTORY_ENTRY_RESOURCE'):
        arr['SizeOfResources'] = len(pe.DIRECTORY_ENTRY_RESOURCE.entries)
    else:
        arr['SizeOfResources'] = 0

    try:
        arr['SizeOfLoadConfig'] = pe.DIRECTORY_ENTRY_LOAD_CONFIG.__sizeof__() if hasattr(pe, 'DIRECTORY_ENTRY_LOAD_CONFIG') else 0
    except AttributeError:
        print('error')
        arr['SizeOfLoadConfig'] = 0

    arr['SizeOfSections'] = len(getattr(pe, 'sections', []))

    section_attrs = [
        ['RawSize', 'SizeOfRawData'],
        ['PhysicalAddress', 'Misc_PhysicalAddress'],
        ['VirtualSize', 'Misc_VirtualSize'],
        ['VirtualAddress', 'VirtualAddress'],
        ['RawData', 'PointerToRawData'],
        ['Characteristics', 'Characteristics']
    ]

    for key, value in section_attrs:
        temp = [getattr(s, value, [0]) for s in getattr(pe, 'sections', [0])]
        arr[f'SectionMin{key}'], arr[f'SectionMax{key}'], arr[f'SectionMean{key}'] = min(temp), max(temp), int(mean(temp))

    entropy = [s.get_entropy() for s in getattr(pe, 'sections', [])]
    arr['SectionMinEntropy'], arr['SectionMaxEntropy'], arr['SectionMeanEntropy'] = (min(entropy), max(entropy), int(mean(entropy))) if entropy else (0, 0, 0)

    arr['NumberOfImports'] = len(getattr(pe, 'DIRECTORY_ENTRY_IMPORT', []))
    arr['SizeOfImports'] = sum(len(x.imports) for x in getattr(pe, 'DIRECTORY_ENTRY_IMPORT', []))

    if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT'):
        arr['NumberOfExports'] = len(pe.DIRECTORY_ENTRY_EXPORT.symbols)
        arr['SizeOfExports'] = sum(x.__sizeof__() for x in pe.DIRECTORY_ENTRY_EXPORT.symbols)
    else:
        arr['NumberOfExports'] = 0
        arr['SizeOfExports'] = 0

    arr['MD5'] = hashlib.md5(pe.__data__).hexdigest()

    return {x: arr[x] for x in sorted(arr)}

def is_compatible(file_path):
    try:
        PE(file_path, fast_load=True)
        return True
    except PEFormatError:
        return False

def get_files(path):

    for element in os.listdir(path):
        if element in IGNORED_FOLDERS:
            continue
        element_path = os.path.join(path, element)
        if os.path.isfile(element_path):
            yield element_path
        elif os.path.isdir(element_path):
            yield from get_files(element_path)

def get_unique_code():
    global used_codes
    code = random.randint(10000000, 99999999)
    while code in used_codes:
        code = random.randint(10000000, 99999999)
    used_codes.append(code)
    return code

def save_files(save_path, file_paths, custom_parent=None, save_increment=1000):

    if os.path.exists(save_path):
        with open(save_path, 'r', encoding='utf-8') as f:
            files = json.load(f)
            saved_files = [info[0] for info in files]
    else:
        files = []
        saved_files = []

    for path in file_paths:
        for i, filepath in enumerate(get_files(path)):
            if filepath in saved_files or not os.path.exists(filepath) or not is_compatible(filepath):
                continue
            parent = custom_parent if custom_parent else path.split('\\')[1]
            files.append([filepath, parent, get_unique_code()])
            if i % save_increment == 0 and i != 0:
                with open(save_path, 'w', encoding='utf-8') as f:
                    json.dump(files, f, indent=4)
                print(i, parent)
        print(f'Saved all files in {path}')
        with open(save_path, 'w', encoding='utf-8') as f:
            json.dump(files, f, indent=4)

def save_data(save_path, files, malware_flag, save_increment=1000):

    if os.path.exists(save_path):
        with open(save_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
    else:
        data = {}

    for i, info in enumerate(files):
        filepath, parent, code = info
        if str(code) in data:
            continue
        attributes = get_attributes(filepath)
        if attributes:
            data[code] = {
                'malware': malware_flag,
                'code': code,
                'parent': parent,
                **attributes,
            }
        if i % save_increment == 0:
            with open(save_path, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=4)
            print(f'{i}/{len(files)}')
    with open(save_path, 'w', encoding='utf-8') as f:
        json.dump(data, f, indent=4)


if __name__ == '__main__':

    used_codes = []
    for file in ['benign_files.json', 'malware_files.json']:
        if os.path.exists(file):
            with open(file, 'r', encoding='utf-8') as f:
                used_codes.extend([info[2] for info in json.load(f)])


    # Get benign files
    print('Getting benign files...')

    save_files('benign_files.json', BENIGN_FILE_PATHS, custom_parent='LocalMachine')

    print('Got benign files!')

    # Get malware files
    print('Getting malware files...')

    save_files('malware_files.json', MALWARE_FILE_PATHS)

    print('Got malware files!')


    # Get benign data

    print('Getting benign data...')

    with open('benign_files.json', 'r', encoding='utf-8') as f:
        benign_files = json.load(f)

    save_data('benign_data.json', benign_files, 0)

    print('Got benign data!')

    # Get malware data

    print('Getting malware data...')

    with open('malware_files.json', 'r', encoding='utf-8') as f:
        malware_files = json.load(f)

    save_data('malware_data.json', malware_files, 1)

    print('Got malware data!')