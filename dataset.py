import hashlib
import random
import json
import os

from pefile import PE, PEFormatError
from numpy import mean

## Change the below variables as necessary ##

BENIGN_FILE_PATHS = ['C:\\', 'D:\\'] # Sourced from local machine

MALWARE_FILE_PATHS = [ # Sourced from VirusShare (https://virusshare.com/)
    'E:\\VirusShare_00459',
    'E:\\VirusShare_00460',
    'E:\\VirusShare_00461',
    'E:\\VirusShare_00462',
    'E:\\VirusShare_00463',
    'E:\\VirusShare_00464',
    'E:\\VirusShare_00465',
    'E:\\VirusShare_00466',
]

# Junctions and folders to ignore when traversing file system
IGNORED_FOLDERS = [
    '$Recycle.Bin',
    'Documents and Settings',
    'Application Data',
    'Cookies',
    'Local Settings',
    'NetHood',
    'PrintHood',
    'Recent',
    'SendTo',
    'Start Menu',
    'Templates',
    'Temporary Internet Files',

    # My additions
    '_Coding',
]

## End of variables ##

def get_attributes(file_path, malware=1):
    try:
        pe = PE(file_path)
    except PEFormatError:
        print('Not a PE file')
        return {}

    # Set array name and malware flag

    arr = {
        'Name': file_path.split('\\')[-1],
        'Malware': malware,
    }

    # Get MD5 hash

    arr['MD5'] = hashlib.md5(pe.__data__).hexdigest()

    # Get DOS header data

    dos_header_data = {
        'e_magic': ('e_magic', 0),
        'e_cblp': ('e_cblp', 0),
        'e_cp': ('e_cp', 0),
        'e_crlc': ('e_crlc', 0),
        'e_cparhdr': ('e_cparhdr', 0),
        'e_minalloc': ('e_minalloc', 0),
        'e_maxalloc': ('e_maxalloc', 0),
        'e_ss': ('e_ss', 0),
        'e_sp': ('e_sp', 0),
        'e_csum': ('e_csum', 0),
        'e_ip': ('e_ip', 0),
        'e_cs': ('e_cs', 0),
        'e_lfarlc': ('e_lfarlc', 0),
        'e_ovno': ('e_ovno', 0),
        'e_oemid': ('e_oemid', 0),
        'e_oeminfo': ('e_oeminfo', 0),
        'e_lfanew': ('e_lfanew', 0),
    }

    for key, value in dos_header_data.items():
        arr[key] = getattr(pe.DOS_HEADER, value[0], value[1])

    # Get NT header data

    nt_header_data = {
        'Signature': ('Signature', 0),
    }

    for key, value in nt_header_data.items():
        arr[key] = getattr(pe.NT_HEADERS, value[0], value[1])

    # Get file header data

    file_header_data = {
        'Machine': ('Machine', 0),
        'NumberOfSections': ('NumberOfSections', 0),
        # 'TimeDateStamp': ('TimeDateStamp', 0),
        'PointerToSymbolTable': ('PointerToSymbolTable', 0),
        'NumberOfSymbols': ('NumberOfSymbols', 0),
        'SizeOfOptionalHeader': ('SizeOfOptionalHeader', 0),
        'Characteristics': ('Characteristics', 0),
    }

    for key, value in file_header_data.items():
        arr[key] = getattr(pe.FILE_HEADER, value[0], value[1])

    # Get optional header data

    optional_header_data = {
        'Magic': ('Magic', 0),
        'MajorLinkerVersion': ('MajorLinkerVersion', 0),
        'MinorLinkerVersion': ('MinorLinkerVersion', 0),
        'SizeOfCode': ('SizeOfCode', 0),
        'SizeOfInitializedData': ('SizeOfInitializedData', 0),
        'SizeOfUninitializedData': ('SizeOfUninitializedData', 0),
        'AddressOfEntryPoint': ('AddressOfEntryPoint', 0),
        'BaseOfCode': ('BaseOfCode', 0),
        'ImageBase': ('ImageBase', 0),
        'SectionAlignment': ('SectionAlignment', 0),
        'FileAlignment': ('FileAlignment', 0),
        'MajorOperatingSystemVersion': ('MajorOperatingSystemVersion', 0),
        'MinorOperatingSystemVersion': ('MinorOperatingSystemVersion', 0),
        'MajorImageVersion': ('MajorImageVersion', 0),
        'MinorImageVersion': ('MinorImageVersion', 0),
        'MajorSubsystemVersion': ('MajorSubsystemVersion', 0),
        'MinorSubsystemVersion': ('MinorSubsystemVersion', 0),
        'SizeOfImage': ('SizeOfImage', 0),
        'SizeOfHeaders': ('SizeOfHeaders', 0),
        'CheckSum': ('CheckSum', 0),
        'Subsystem': ('Subsystem', 0),
        'SizeOfStackReserve': ('SizeOfStackReserve', 0),
        'SizeOfStackCommit': ('SizeOfStackCommit', 0),
        'SizeOfHeapReserve': ('SizeOfHeapReserve', 0),
        'SizeOfHeapCommit': ('SizeOfHeapCommit', 0),
        'LoaderFlags': ('LoaderFlags', 0),
        'NumberOfRvaAndSizes': ('NumberOfRvaAndSizes', 0),
        'DllCharacteristics': ('DllCharacteristics', 0),
    }

    for key, value in optional_header_data.items():
        arr[key] = getattr(pe.OPTIONAL_HEADER, value[0], value[1])

    # Get data directory data

    directory_data = {
        'SizeOfExcetion': ('DIRECTORY_ENTRY_EXCEPTION', []),
        'SizeOfSecurity': ('DIRECTORY_ENTRY_SECURITY', []),
        'SizeOfBaseLoc': ('DIRECTORY_ENTRY_BASERELOC', []),
        'SizeOfDebug': ('DIRECTORY_ENTRY_DEBUG', []),
        'SizeOfCopyright': ('DIRECTORY_ENTRY_COPYRIGHT', []),
        'SizeOfGlobalPTR': ('DIRECTORY_ENTRY_GLOBALPTR', []),
        'SizeOfTLS': ('DIRECTORY_ENTRY_TLS', []),
        'SizeOfBoundImport': ('DIRECTORY_ENTRY_BOUND_IMPORT', []),
        'SizeOfIAT': ('DIRECTORY_ENTRY_IAT', []),
        'SizeOfDelayImport': ('DIRECTORY_ENTRY_DELAY_IMPORT', []),
        'SizeOfComDescriptor': ('DIRECTORY_ENTRY_COM_DESCRIPTOR', []),
        'SizeOfReserved': ('DIRECTORY_ENTRY_RESERVED', []),
    }

    for key, value in directory_data.items():
        arr[key] = len(getattr(pe.OPTIONAL_HEADER, value[0], value[1]))

    arr['SizeOfResources'] = len(getattr(pe, 'DIRECTORY_ENTRY_RESOURCE', {'entries': []}).entries)
    arr['SizeOfLoadConfig'] = pe.DIRECTORY_ENTRY_LOAD_CONFIG.__sizeof__() if hasattr(pe, 'DIRECTORY_ENTRY_LOAD_CONFIG') else 0

    # Get section data

    arr['SizeOfSections'] = len(getattr(pe, 'sections', []))

    section_data = {
        'RawSize':  ('SizeOfRawData', [0]),
        'PhysicalAddress': ('Misc_PhysicalAddress', [0]),
        'VirtualSize': ('Misc_VirtualSize', [0]),
        'VirtualAddress': ('VirtualAddress', [0]),
        'RawData': ('PointerToRawData', [0]),
        'Characteristics': ('Characteristics', [0]),
    }

    for key, value in section_data.items():
        temp = [getattr(s, value[0], value[1]) for s in pe.sections]
        arr[f'SectionMin{key}'] = min(temp)
        arr[f'SectionMax{key}'] = max(temp)
        arr[f'SectionMean{key}'] = int(mean(temp))

    entropy = [s.get_entropy() for s in pe.sections] if hasattr(pe, 'sections') else [0]

    arr['SectionMinEntropy'] = min(entropy)
    arr['SectionMaxEntropy'] = max(entropy)
    arr['SectionMeanEntropy'] = int(mean(entropy))

    # Get import/export data

    imports = getattr(pe, 'DIRECTORY_ENTRY_IMPORT', [])
    exports = getattr(pe, 'DIRECTORY_ENTRY_EXPORT', [])

    arr['NumberOfImports'] = len(imports)
    arr['NumberOfExports'] = len(exports)
    arr['SizeOfImports'] = sum(len(x.imports) for x in imports)
    arr['SizeOfExports'] = sum(len(x.exports) for x in exports)

    # Sort the dictionary alphabetically and return it

    arr = {x: arr[x] for x in sorted(arr)}
    pe.close()

    return arr

def get_files(path):

    for element in os.listdir(path):
        if element in IGNORED_FOLDERS:
            continue
        element_path = os.path.join(path, element)
        if os.path.isfile(element_path):
            yield element_path
        elif os.path.isdir(element_path):
            yield from get_files(element_path)

def get_unique_code():
    global used_codes
    code = random.randint(10000000, 99999999)
    while code in used_codes:
        code = random.randint(10000000, 99999999)
    used_codes.append(code)
    return code

def save_files(save_path, file_paths, custom_parent=None, save_increment=1000):

    if os.path.exists(save_path):
        with open(save_path, 'r', encoding='utf-8') as f:
            files = json.load(f)
            saved_files = [info[0] for info in files]
    else:
        files = []
        saved_files = []

    for path in file_paths:
        for i, filepath in enumerate(get_files(path)):
            if filepath in saved_files:
                continue
            parent = custom_parent if custom_parent else path.split('\\')[1]
            files.append([filepath, parent, get_unique_code()])
            if i % save_increment == 0 and i != 0:
                with open(save_path, 'w', encoding='utf-8') as f:
                    json.dump(files, f, indent=4)
                print(i, parent)
        with open(save_path, 'w', encoding='utf-8') as f:
            json.dump(files, f, indent=4)

def save_data(save_path, files, malware_flag, save_increment=1000):

    if os.path.exists(save_path):
        with open(save_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
    else:
        data = []

    for i, info in enumerate(files):
        filepath, parent, code = info
        if str(code) in data:
            continue
        attributes = get_attributes(filepath)
        if attributes:
            data[code] = {
                'malware': malware_flag,
                'code': code,
                'parent': parent,
                **attributes,
            }
        if i % save_increment == 0:
            with open(save_path, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=4)
            print(f'{i}/{len(files)}')
    with open(save_path, 'w', encoding='utf-8') as f:
        json.dump(data, f, indent=4)


if __name__ == '__main__':

    used_codes = []
    for file in ['benign_files.json', 'malware_files.json']:
        if os.path.exists(file):
            with open(file, 'r', encoding='utf-8') as f:
                used_codes.extend([info[2] for info in json.load(f)])


    # Get benign files
    print('Getting benign files...')

    save_files('benign_files.json', BENIGN_FILE_PATHS, custom_parent='LocalMachine')

    print('Got benign files!')

    # Get malware files
    print('Getting malware files...')

    save_files('malware_files.json', MALWARE_FILE_PATHS)

    print('Got malware files!')


    # Get benign data

    print('Getting benign data...')

    with open('benign_files.json', 'r', encoding='utf-8') as f:
        benign_files = json.load(f)

    save_data('benign_data.json', benign_files, 0)

    print('Got benign data!')

    # Get malware data

    print('Getting malware data...')

    with open('malware_files.json', 'r', encoding='utf-8') as f:
        malware_files = json.load(f)

    save_data('malware_data.json', malware_files, 1)

    print('Got malware data!')