#include <iostream>
#include <fstream>
#include <vector>
#include <numeric>
#include <algorithm>
#include <cmath>

#include <PEFile.h>

PEFileAnalyser::PEFileAnalyser(const std::string& filePath) : file(filePath) {
    std::cout << "Opening file: " << filePath << std::endl;
    std::ifstream file(filePath, std::ios::binary);
}

void PEFileAnalyser::analyse(std::vector<std::string> keys, std::vector<double> values) {
    if (!file.is_open()) {
        std::cout << "File is not open" << std::endl;
        return;
    }

    // #pragma pack(push, 1)

    readDOSHeader();

    if (!isValidDOSHeader()) {
        std::cout << "Invalid DOS header" << std::endl;
        return;
    }

    readCOFFHeader();
    std::cout << "COFF Header: " << coffHeader.Machine << std::endl;
    readOptionalHeader();
    std::cout << "Optional Header: " << optionalHeader.Magic << std::endl;
    readSections();
    std::cout << "Number of Sections: " << coffHeader.NumberOfSections << std::endl;
    calculateSectionAttributes();
    std::cout << "Section Attributes Calculated" << std::endl;
    readDataDirectory();
    std::cout << "Data Directory: " << dataDirectory.ExportTable << std::endl;
    readExportDirectory();
    std::cout << "Export Directory: " << exportDirectory.NumberOfFunctions << std::endl;
    readImportDirectory();
    std::cout << "Import Directory: " << importDescriptor.OriginalFirstThunk << std::endl;
    countImportsAndExports();
    std::cout << "Imports and Exports counted" << std::endl;

    // #pragma pack(pop) // Restore default packing

    keys = getKeys();
    values = getValues();

    file.close();
}

std::vector<uint8_t> PEFileAnalyser::readFileBytes() {

    if (!file.is_open()) {
        std::cout << "File is not open" << std::endl;
        return {};
    }

    // Get current position in file
    std::streampos currentPosition = file.tellg();

    // Get the file size
    file.seekg(0, std::ios::end);
    std::streamsize fileSize = file.tellg();

    // Reset the file position
    file.seekg(currentPosition, std::ios::beg);

    // Read the file contents into a vector
    std::vector<uint8_t> fileData(fileSize);
    // file.read(reinterpret_cast<char*>(fileData.data()), fileSize);
    if (!file.read(reinterpret_cast<char*>(fileData.data()), fileSize)) {
        std::cout << "Failed to read file" << std::endl;
        return {};
    }

    return fileData;
}

void PEFileAnalyser::readDOSHeader() {
    file.read(reinterpret_cast<char*>(&dosHeader), sizeof(IMAGE_DOS_HEADER));
}

bool PEFileAnalyser::isValidDOSHeader() {
    std::cout << "DOS Header: " << dosHeader.e_magic << std::endl;
    return dosHeader.e_magic == 0x5A4D;
}

void PEFileAnalyser::readCOFFHeader() {
    file.read(reinterpret_cast<char*>(&coffHeader), sizeof(IMAGE_FILE_HEADER));
}

void PEFileAnalyser::readOptionalHeader() {
    file.read(reinterpret_cast<char*>(&optionalHeader), sizeof(IMAGE_OPTIONAL_HEADER));
}

void PEFileAnalyser::readSections() {
    sections.resize(coffHeader.NumberOfSections);
    file.read(reinterpret_cast<char*>(sections.data()), sizeof(IMAGE_SECTION_HEADER) * coffHeader.NumberOfSections);
}

void PEFileAnalyser::calculateSectionAttributes() {
    std::vector<int> sectionVirtualSize;
    std::vector<int> sectionVirtualAddress;
    std::vector<int> sectionSizeOfRawData;
    std::vector<int> sectionPointerToRawData;
    std::vector<int> sectionPointerToRelocations;
    std::vector<int> sectionPointerToLinenumbers;
    std::vector<int> sectionNumberOfRelocations;
    std::vector<int> sectionNumberOfLinenumbers;
    std::vector<int> sectionCharacteristics;

    for (const IMAGE_SECTION_HEADER& section : sections) {
        sectionVirtualSize.push_back(section.VirtualSize);
        sectionVirtualAddress.push_back(section.VirtualAddress);
        sectionSizeOfRawData.push_back(section.SizeOfRawData);
        sectionPointerToRawData.push_back(section.PointerToRawData);
        sectionPointerToRelocations.push_back(section.PointerToRelocations);
        sectionPointerToLinenumbers.push_back(section.PointerToLinenumbers);
        sectionNumberOfRelocations.push_back(section.NumberOfRelocations);
        sectionNumberOfLinenumbers.push_back(section.NumberOfLinenumbers);
        sectionCharacteristics.push_back(section.Characteristics);
    }

    sectionData.MaxVirtualSize = *std::max_element(sectionVirtualSize.begin(), sectionVirtualSize.end());
    sectionData.MaxVirtualAddress = *std::max_element(sectionVirtualAddress.begin(), sectionVirtualAddress.end());
    sectionData.MaxSizeOfRawData = *std::max_element(sectionSizeOfRawData.begin(), sectionSizeOfRawData.end());
    sectionData.MaxPointerToRawData = *std::max_element(sectionPointerToRawData.begin(), sectionPointerToRawData.end());
    sectionData.MaxPointerToRelocations = *std::max_element(sectionPointerToRelocations.begin(), sectionPointerToRelocations.end());
    sectionData.MaxPointerToLinenumbers = *std::max_element(sectionPointerToLinenumbers.begin(), sectionPointerToLinenumbers.end());
    sectionData.MaxNumberOfRelocations = *std::max_element(sectionNumberOfRelocations.begin(), sectionNumberOfRelocations.end());
    sectionData.MaxNumberOfLinenumbers = *std::max_element(sectionNumberOfLinenumbers.begin(), sectionNumberOfLinenumbers.end());
    sectionData.MaxCharacteristics = *std::max_element(sectionCharacteristics.begin(), sectionCharacteristics.end());

    sectionData.MinVirtualSize = *std::min_element(sectionVirtualSize.begin(), sectionVirtualSize.end());
    sectionData.MinVirtualAddress = *std::min_element(sectionVirtualAddress.begin(), sectionVirtualAddress.end());
    sectionData.MinSizeOfRawData = *std::min_element(sectionSizeOfRawData.begin(), sectionSizeOfRawData.end());
    sectionData.MinPointerToRawData = *std::min_element(sectionPointerToRawData.begin(), sectionPointerToRawData.end());
    sectionData.MinPointerToRelocations = *std::min_element(sectionPointerToRelocations.begin(), sectionPointerToRelocations.end());
    sectionData.MinPointerToLinenumbers = *std::min_element(sectionPointerToLinenumbers.begin(), sectionPointerToLinenumbers.end());
    sectionData.MinNumberOfRelocations = *std::min_element(sectionNumberOfRelocations.begin(), sectionNumberOfRelocations.end());
    sectionData.MinNumberOfLinenumbers = *std::min_element(sectionNumberOfLinenumbers.begin(), sectionNumberOfLinenumbers.end());
    sectionData.MinCharacteristics = *std::min_element(sectionCharacteristics.begin(), sectionCharacteristics.end());

    sectionData.MeanVirtualSize = std::accumulate(sectionVirtualSize.begin(), sectionVirtualSize.end(), 0) / sectionVirtualSize.size();
    sectionData.MeanVirtualAddress = std::accumulate(sectionVirtualAddress.begin(), sectionVirtualAddress.end(), 0) / sectionVirtualAddress.size();
    sectionData.MeanSizeOfRawData = std::accumulate(sectionSizeOfRawData.begin(), sectionSizeOfRawData.end(), 0) / sectionSizeOfRawData.size();
    sectionData.MeanPointerToRawData = std::accumulate(sectionPointerToRawData.begin(), sectionPointerToRawData.end(), 0) / sectionPointerToRawData.size();
    sectionData.MeanPointerToRelocations = std::accumulate(sectionPointerToRelocations.begin(), sectionPointerToRelocations.end(), 0) / sectionPointerToRelocations.size();
    sectionData.MeanPointerToLinenumbers = std::accumulate(sectionPointerToLinenumbers.begin(), sectionPointerToLinenumbers.end(), 0) / sectionPointerToLinenumbers.size();
    sectionData.MeanNumberOfRelocations = std::accumulate(sectionNumberOfRelocations.begin(), sectionNumberOfRelocations.end(), 0) / sectionNumberOfRelocations.size();
    sectionData.MeanNumberOfLinenumbers = std::accumulate(sectionNumberOfLinenumbers.begin(), sectionNumberOfLinenumbers.end(), 0) / sectionNumberOfLinenumbers.size();
    sectionData.MeanCharacteristics = std::accumulate(sectionCharacteristics.begin(), sectionCharacteristics.end(), 0) / sectionCharacteristics.size();

    std::cout << "Max Virtual Size: " << sectionData.MaxVirtualSize << std::endl;

    // Get entropy of each section
    std::vector<double> sectionEntropy;
    for (const IMAGE_SECTION_HEADER& section : sections) {
        std::vector<uint8_t> sectionData = readFileBytes();
        std::cout << "Section Data Size: " << sectionData.size() << std::endl;
        std::vector<uint8_t> sectionBytes(sectionData.begin() + section.PointerToRawData, sectionData.begin() + section.PointerToRawData + section.SizeOfRawData);
        std::vector<int> counts(256, 0);
        for (const auto& byte : sectionBytes) {
            counts[byte]++;
        }
        double entropy = 0;
        for (const auto& count : counts) {
            if (count != 0) {
                double probability = static_cast<double>(count) / sectionBytes.size();
                entropy -= probability * std::log2(probability);
            }
        }
        sectionEntropy.push_back(entropy);
    }

    std::cout << "Section Entropy Calculated" << std::endl;

    sectionData.MaxEntropy = *std::max_element(sectionEntropy.begin(), sectionEntropy.end());
    sectionData.MinEntropy = *std::min_element(sectionEntropy.begin(), sectionEntropy.end());
    sectionData.MeanEntropy = std::accumulate(sectionEntropy.begin(), sectionEntropy.end(), 0.0) / sectionEntropy.size();
}

void PEFileAnalyser::readDataDirectory() {
    file.read(reinterpret_cast<char*>(&dataDirectory), sizeof(IMAGE_DATA_DIRECTORY));
}

void PEFileAnalyser::readExportDirectory() {
    file.seekg(dataDirectory.ExportTable, std::ios::beg);
    file.read(reinterpret_cast<char*>(&exportDirectory), sizeof(IMAGE_EXPORT_DIRECTORY));
}

void PEFileAnalyser::readImportDirectory() {
    file.seekg(dataDirectory.ImportTable, std::ios::beg);
    file.read(reinterpret_cast<char*>(&importDescriptor), sizeof(IMAGE_IMPORT_DESCRIPTOR));
}

void PEFileAnalyser::countImportsAndExports() {
    numberOfImports = 0;
    numberOfExports = 0;

    if (importDescriptor.OriginalFirstThunk != 0) {
        numberOfImports++;
    }

    if (exportDirectory.NumberOfFunctions != 0) {
        numberOfExports++;
    }
}

std::vector<std::string> PEFileAnalyser::getKeys(const IMAGE_DOS_HEADER & dosHeader) {
    return {
        "e_magic",
        "e_cblp",
        "e_cp",
        "e_crlc",
        "e_cparhdr",
        "e_minalloc",
        "e_maxalloc",
        "e_ss",
        "e_sp",
        "e_csum",
        "e_ip",
        "e_cs",
        "e_lfarlc",
        "e_ovno",
        "e_oemid",
        "e_oeminfo",
        "e_lfanew"
    };
}

std::vector<std::string> PEFileAnalyser::getKeys(const IMAGE_OPTIONAL_HEADER& optionalHeader) {
    return {
        "Magic",
        "MajorLinkerVersion",
        "MinorLinkerVersion",
        "SizeOfCode",
        "SizeOfInitializedData",
        "SizeOfUninitializedData",
        "AddressOfEntryPoint",
        "BaseOfCode",
        "BaseOfData",
        "ImageBase",
        "SectionAlignment",
        "FileAlignment",
        "MajorOperatingSystemVersion",
        "MinorOperatingSystemVersion",
        "MajorImageVersion",
        "MinorImageVersion",
        "MajorSubsystemVersion",
        "MinorSubsystemVersion",
        "Win32VersionValue",
        "SizeOfImage",
        "SizeOfHeaders",
        "CheckSum",
        "Subsystem",
        "DllCharacteristics",
        "SizeOfStackReserve",
        "SizeOfStackCommit",
        "SizeOfHeapReserve",
        "SizeOfHeapCommit",
        "LoaderFlags",
        "NumberOfRvaAndSizes"
    };
}

std::vector<std::string> PEFileAnalyser::getKeys(const IMAGE_SECTION_DATA& sectionData) {
    return {
        "MaxVirtualSize",
        "MinVirtualSize",
        "MeanVirtualSize",
        "MaxVirtualAddress",
        "MinVirtualAddress",
        "MeanVirtualAddress",
        "MaxSizeOfRawData",
        "MinSizeOfRawData",
        "MeanSizeOfRawData",
        "MaxPointerToRawData",
        "MinPointerToRawData",
        "MeanPointerToRawData",
        "MaxPointerToRelocations",
        "MinPointerToRelocations",
        "MeanPointerToRelocations",
        "MaxPointerToLinenumbers",
        "MinPointerToLinenumbers",
        "MeanPointerToLinenumbers",
        "MaxNumberOfRelocations",
        "MinNumberOfRelocations",
        "MeanNumberOfRelocations",
        "MaxNumberOfLinenumbers",
        "MinNumberOfLinenumbers",
        "MeanNumberOfLinenumbers",
        "MaxCharacteristics",
        "MinCharacteristics",
        "MeanCharacteristics",
        "MaxEntropy",
        "MinEntropy",
        "MeanEntropy"
    };
}

std::vector<std::string> PEFileAnalyser::getKeys(const IMAGE_DATA_DIRECTORY& imageDataDirectory) {
    return {
        "NumberOfImports",
        "NumberOfExports",
    };
}

std::vector<std::string> PEFileAnalyser::getKeys() {
    // Get vector of keys from each struct
    std::vector<std::string> dosHeaderKeys = getKeys(dosHeader);
    std::vector<std::string> optionalHeaderKeys = getKeys(optionalHeader);
    std::vector<std::string> sectionDataKeys = getKeys(sectionData);
    std::vector<std::string> imageDataKeys = getKeys(dataDirectory);

    std::vector<std::string> keys;
    keys.insert(keys.end(), dosHeaderKeys.begin(), dosHeaderKeys.end());
    keys.insert(keys.end(), optionalHeaderKeys.begin(), optionalHeaderKeys.end());
    keys.insert(keys.end(), sectionDataKeys.begin(), sectionDataKeys.end());
    keys.insert(keys.end(), imageDataKeys.begin(), imageDataKeys.end());

    return keys;
}

std::vector<double> PEFileAnalyser::getValues(const IMAGE_DOS_HEADER& dosHeader) {
    return {
        static_cast<double>(dosHeader.e_magic),
        static_cast<double>(dosHeader.e_cblp),
        static_cast<double>(dosHeader.e_cp),
        static_cast<double>(dosHeader.e_crlc),
        static_cast<double>(dosHeader.e_cparhdr),
        static_cast<double>(dosHeader.e_minalloc),
        static_cast<double>(dosHeader.e_maxalloc),
        static_cast<double>(dosHeader.e_ss),
        static_cast<double>(dosHeader.e_sp),
        static_cast<double>(dosHeader.e_csum),
        static_cast<double>(dosHeader.e_ip),
        static_cast<double>(dosHeader.e_cs),
        static_cast<double>(dosHeader.e_lfarlc),
        static_cast<double>(dosHeader.e_ovno),
        static_cast<double>(dosHeader.e_oemid),
        static_cast<double>(dosHeader.e_oeminfo),
        static_cast<double>(dosHeader.e_lfanew)
    };
}

std::vector<double> PEFileAnalyser::getValues(const IMAGE_OPTIONAL_HEADER& optionalHeader) {
    return {
        static_cast<double>(optionalHeader.Magic),
        static_cast<double>(optionalHeader.MajorLinkerVersion),
        static_cast<double>(optionalHeader.MinorLinkerVersion),
        static_cast<double>(optionalHeader.SizeOfCode),
        static_cast<double>(optionalHeader.SizeOfInitializedData),
        static_cast<double>(optionalHeader.SizeOfUninitializedData),
        static_cast<double>(optionalHeader.AddressOfEntryPoint),
        static_cast<double>(optionalHeader.BaseOfCode),
        static_cast<double>(optionalHeader.BaseOfData),
        static_cast<double>(optionalHeader.ImageBase),
        static_cast<double>(optionalHeader.SectionAlignment),
        static_cast<double>(optionalHeader.FileAlignment),
        static_cast<double>(optionalHeader.MajorOperatingSystemVersion),
        static_cast<double>(optionalHeader.MinorOperatingSystemVersion),
        static_cast<double>(optionalHeader.MajorImageVersion),
        static_cast<double>(optionalHeader.MinorImageVersion),
        static_cast<double>(optionalHeader.MajorSubsystemVersion),
        static_cast<double>(optionalHeader.MinorSubsystemVersion),
        static_cast<double>(optionalHeader.Win32VersionValue),
        static_cast<double>(optionalHeader.SizeOfImage),
        static_cast<double>(optionalHeader.SizeOfHeaders),
        static_cast<double>(optionalHeader.CheckSum),
        static_cast<double>(optionalHeader.Subsystem),
        static_cast<double>(optionalHeader.DllCharacteristics),
        static_cast<double>(optionalHeader.SizeOfStackReserve),
        static_cast<double>(optionalHeader.SizeOfStackCommit),
        static_cast<double>(optionalHeader.SizeOfHeapReserve),
        static_cast<double>(optionalHeader.SizeOfHeapCommit),
        static_cast<double>(optionalHeader.LoaderFlags),
        static_cast<double>(optionalHeader.NumberOfRvaAndSizes)
    };
}

std::vector<double> PEFileAnalyser::getValues(const IMAGE_SECTION_DATA& sectionData) {
    return {
        static_cast<double>(sectionData.MaxVirtualSize),
        static_cast<double>(sectionData.MinVirtualSize),
        static_cast<double>(sectionData.MeanVirtualSize),
        static_cast<double>(sectionData.MaxVirtualAddress),
        static_cast<double>(sectionData.MinVirtualAddress),
        static_cast<double>(sectionData.MeanVirtualAddress),
        static_cast<double>(sectionData.MaxSizeOfRawData),
        static_cast<double>(sectionData.MinSizeOfRawData),
        static_cast<double>(sectionData.MeanSizeOfRawData),
        static_cast<double>(sectionData.MaxPointerToRawData),
        static_cast<double>(sectionData.MinPointerToRawData),
        static_cast<double>(sectionData.MeanPointerToRawData),
        static_cast<double>(sectionData.MaxPointerToRelocations),
        static_cast<double>(sectionData.MinPointerToRelocations),
        static_cast<double>(sectionData.MeanPointerToRelocations),
        static_cast<double>(sectionData.MaxPointerToLinenumbers),
        static_cast<double>(sectionData.MinPointerToLinenumbers),
        static_cast<double>(sectionData.MeanPointerToLinenumbers),
        static_cast<double>(sectionData.MaxNumberOfRelocations),
        static_cast<double>(sectionData.MinNumberOfRelocations),
        static_cast<double>(sectionData.MeanNumberOfRelocations),
        static_cast<double>(sectionData.MaxNumberOfLinenumbers),
        static_cast<double>(sectionData.MinNumberOfLinenumbers),
        static_cast<double>(sectionData.MeanNumberOfLinenumbers),
        static_cast<double>(sectionData.MaxCharacteristics),
        static_cast<double>(sectionData.MinCharacteristics),
        static_cast<double>(sectionData.MeanCharacteristics),
        static_cast<double>(sectionData.MaxEntropy),
        static_cast<double>(sectionData.MinEntropy),
        static_cast<double>(sectionData.MeanEntropy)
    };
}

std::vector<double> PEFileAnalyser::getValues(const IMAGE_DATA_DIRECTORY& imageDataDirectory) {
    return {
        static_cast<double>(numberOfImports),
        static_cast<double>(numberOfExports)
    };
}

std::vector<double> PEFileAnalyser::getValues() {
    // Get vector of values from each struct
    std::vector<double> dosHeaderValues = getValues(dosHeader);
    std::vector<double> optionalHeaderValues = getValues(optionalHeader);
    std::vector<double> sectionDataValues = getValues(sectionData);
    std::vector<double> imageDataValues = getValues(dataDirectory);

    std::vector<double> values;
    values.insert(values.end(), dosHeaderValues.begin(), dosHeaderValues.end());
    values.insert(values.end(), optionalHeaderValues.begin(), optionalHeaderValues.end());
    values.insert(values.end(), sectionDataValues.begin(), sectionDataValues.end());
    values.insert(values.end(), imageDataValues.begin(), imageDataValues.end());

    return values;
}