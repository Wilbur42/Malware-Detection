#include <iostream>
#include <fstream>
#include <vector>
#include <numeric>
#include <algorithm>
#include <cmath>

#include <PEFile.h>
#include <crypt.h>

PEFileAnalyser::PEFileAnalyser(const std::string& filePath) : file(filePath) {
    this->filePath = filePath;

    std::cout << "Opening file: " << filePath << std::endl;
    std::ifstream file(filePath, std::ios::binary);

    file.seekg(0, std::ios::end);
    fileSize = file.tellg();
    file.seekg(0, std::ios::beg);

    fileBytes = readFileBytes();
}

void PEFileAnalyser::analyse(std::vector<std::string>& keys, std::vector<double>& values) {
    if (!file.is_open()) {
        std::cout << "File is not open" << std::endl;
        return;
    }

    readDOSHeader();

    if (!isValidDOSHeader()) {
        std::cout << "Invalid DOS header" << std::endl;
        return;
    }

    readCOFFHeader();
    std::cout << "COFF Header: " << coffHeader.NumberOfSections << std::endl;
    readOptionalHeader();
    std::cout << "Optional Header: " << optionalHeader.Magic << std::endl;
    readSections();
    std::cout << "Number of Sections: " << coffHeader.NumberOfSections << std::endl;
    calculateSectionAttributes();
    std::cout << "Section Attributes Calculated" << std::endl;
    std::cout << sectionData.MeanEntropy << std::endl;
    readDataDirectory();
    std::cout << "Data Directory: " << dataDirectory.ExportTable << std::endl;
    // readExportDirectory();
    // std::cout << "Export Directory: " << numberOfExports << std::endl;
    // readImportDirectory();
    // std::cout << "Import Directory: " << numberOfImports << std::endl;
    // countImportsAndExports();
    // std::cout << "Imports and Exports counted" << std::endl;

    calculateHash();
    std::cout << "SHA256 Hash: " << sha256Hash << std::endl;

    keys = getKeys();
    values = getValues();

    file.close();
}

void PEFileAnalyser::calculateHash() {
    std::ifstream f(filePath, std::ios::binary);

    std::string fileContent((std::istreambuf_iterator<char>(f)), std::istreambuf_iterator<char>());

    sha256Hash = sha256(fileContent);
}

std::vector<uint8_t> PEFileAnalyser::readFileBytes() {

    std::cout << filePath << std::endl;

    std::ifstream f(filePath, std::ios::binary);

    if (!f.is_open()) {
        std::cout << "File is not open" << std::endl;
        return {};
    }

    std::cout << "File Size: " << fileSize << std::endl;

    // Read the file contents into a vector
    std::vector<uint8_t> fileData(fileSize);
    f.read(reinterpret_cast<char*>(fileData.data()), fileSize);

    std::cout << fileData.size() << std::endl;

    return fileData;
}

void PEFileAnalyser::readDOSHeader() {
    // Move to DOS Header position
    file.seekg(0, std::ios::beg);
    file.read(reinterpret_cast<char*>(&dosHeader), sizeof(IMAGE_DOS_HEADER));
}

bool PEFileAnalyser::isValidDOSHeader() {
    std::cout << "DOS Header: " << dosHeader.e_magic << std::endl;
    return dosHeader.e_magic == 0x5A4D;
}

void PEFileAnalyser::readCOFFHeader() {
    // Move to COFF Header position
    file.seekg(dosHeader.e_lfanew + sizeof(DWORD));
    file.read(reinterpret_cast<char*>(&coffHeader), sizeof(IMAGE_FILE_HEADER));
}

void PEFileAnalyser::readOptionalHeader() {
    // Move to Optional Header position
    file.seekg(dosHeader.e_lfanew + sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER));
    file.read(reinterpret_cast<char*>(&optionalHeader), sizeof(IMAGE_OPTIONAL_HEADER));
}

void PEFileAnalyser::readSections() {

    std::ifstream f(filePath, std::ios::binary);

    f.seekg(dosHeader.e_lfanew + sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER) + coffHeader.SizeOfOptionalHeader);

    for (int i = 0; i < coffHeader.NumberOfSections; ++i) {

        IMAGE_SECTION_HEADER section;
        f.read(reinterpret_cast<char*>(&section), sizeof(IMAGE_SECTION_HEADER));
        sections.push_back(section);
    }

    f.close();
}

void PEFileAnalyser::calculateSectionAttributes() {
    std::vector<int> sectionVirtualSize;
    std::vector<int> sectionVirtualAddress;
    std::vector<int> sectionSizeOfRawData;
    std::vector<int> sectionPointerToRawData;
    std::vector<int> sectionPointerToRelocations;
    std::vector<int> sectionPointerToLinenumbers;
    std::vector<int> sectionNumberOfRelocations;
    std::vector<int> sectionNumberOfLinenumbers;
    std::vector<int> sectionCharacteristics;

    for (const IMAGE_SECTION_HEADER& section : sections) {
        sectionVirtualSize.push_back(section.VirtualSize);
        sectionVirtualAddress.push_back(section.VirtualAddress);
        sectionSizeOfRawData.push_back(section.SizeOfRawData);
        sectionPointerToRawData.push_back(section.PointerToRawData);
        sectionPointerToRelocations.push_back(section.PointerToRelocations);
        sectionPointerToLinenumbers.push_back(section.PointerToLinenumbers);
        sectionNumberOfRelocations.push_back(section.NumberOfRelocations);
        sectionNumberOfLinenumbers.push_back(section.NumberOfLinenumbers);
        sectionCharacteristics.push_back(section.Characteristics);
    }

    sectionData.MaxVirtualSize = *std::max_element(sectionVirtualSize.begin(), sectionVirtualSize.end());
    sectionData.MaxVirtualAddress = *std::max_element(sectionVirtualAddress.begin(), sectionVirtualAddress.end());
    sectionData.MaxSizeOfRawData = *std::max_element(sectionSizeOfRawData.begin(), sectionSizeOfRawData.end());
    sectionData.MaxPointerToRawData = *std::max_element(sectionPointerToRawData.begin(), sectionPointerToRawData.end());
    sectionData.MaxPointerToRelocations = *std::max_element(sectionPointerToRelocations.begin(), sectionPointerToRelocations.end());
    sectionData.MaxPointerToLinenumbers = *std::max_element(sectionPointerToLinenumbers.begin(), sectionPointerToLinenumbers.end());
    sectionData.MaxNumberOfRelocations = *std::max_element(sectionNumberOfRelocations.begin(), sectionNumberOfRelocations.end());
    sectionData.MaxNumberOfLinenumbers = *std::max_element(sectionNumberOfLinenumbers.begin(), sectionNumberOfLinenumbers.end());
    sectionData.MaxCharacteristics = *std::max_element(sectionCharacteristics.begin(), sectionCharacteristics.end());

    sectionData.MinVirtualSize = *std::min_element(sectionVirtualSize.begin(), sectionVirtualSize.end());
    sectionData.MinVirtualAddress = *std::min_element(sectionVirtualAddress.begin(), sectionVirtualAddress.end());
    sectionData.MinSizeOfRawData = *std::min_element(sectionSizeOfRawData.begin(), sectionSizeOfRawData.end());
    sectionData.MinPointerToRawData = *std::min_element(sectionPointerToRawData.begin(), sectionPointerToRawData.end());
    sectionData.MinPointerToRelocations = *std::min_element(sectionPointerToRelocations.begin(), sectionPointerToRelocations.end());
    sectionData.MinPointerToLinenumbers = *std::min_element(sectionPointerToLinenumbers.begin(), sectionPointerToLinenumbers.end());
    sectionData.MinNumberOfRelocations = *std::min_element(sectionNumberOfRelocations.begin(), sectionNumberOfRelocations.end());
    sectionData.MinNumberOfLinenumbers = *std::min_element(sectionNumberOfLinenumbers.begin(), sectionNumberOfLinenumbers.end());
    sectionData.MinCharacteristics = *std::min_element(sectionCharacteristics.begin(), sectionCharacteristics.end());

    sectionData.MeanVirtualSize = std::accumulate(sectionVirtualSize.begin(), sectionVirtualSize.end(), 0) / sectionVirtualSize.size();
    sectionData.MeanVirtualAddress = std::accumulate(sectionVirtualAddress.begin(), sectionVirtualAddress.end(), 0) / sectionVirtualAddress.size();
    sectionData.MeanSizeOfRawData = std::accumulate(sectionSizeOfRawData.begin(), sectionSizeOfRawData.end(), 0) / sectionSizeOfRawData.size();
    sectionData.MeanPointerToRawData = std::accumulate(sectionPointerToRawData.begin(), sectionPointerToRawData.end(), 0) / sectionPointerToRawData.size();
    sectionData.MeanPointerToRelocations = std::accumulate(sectionPointerToRelocations.begin(), sectionPointerToRelocations.end(), 0) / sectionPointerToRelocations.size();
    sectionData.MeanPointerToLinenumbers = std::accumulate(sectionPointerToLinenumbers.begin(), sectionPointerToLinenumbers.end(), 0) / sectionPointerToLinenumbers.size();
    sectionData.MeanNumberOfRelocations = std::accumulate(sectionNumberOfRelocations.begin(), sectionNumberOfRelocations.end(), 0) / sectionNumberOfRelocations.size();
    sectionData.MeanNumberOfLinenumbers = std::accumulate(sectionNumberOfLinenumbers.begin(), sectionNumberOfLinenumbers.end(), 0) / sectionNumberOfLinenumbers.size();
    sectionData.MeanCharacteristics = std::accumulate(sectionCharacteristics.begin(), sectionCharacteristics.end(), 0) / sectionCharacteristics.size();

    std::cout << "Max Virtual Size: " << sectionData.MaxVirtualSize << std::endl;

    // Get entropy of each section
    std::vector<double> sectionEntropy;
    for (const IMAGE_SECTION_HEADER& section : sections) {
        std::vector<uint8_t> sectionBytes(fileBytes.begin() + section.PointerToRawData, fileBytes.begin() + section.PointerToRawData + section.SizeOfRawData);
        std::vector<int> counts(256, 0);
        for (const auto& byte : sectionBytes) {
            counts[byte]++;
        }
        double entropy = 0;
        for (const auto& count : counts) {
            if (count != 0) {
                double probability = static_cast<double>(count) / sectionBytes.size();
                entropy -= probability * std::log2(probability);
            }
        }
        sectionEntropy.push_back(entropy);
    }

    sectionData.MaxEntropy = *std::max_element(sectionEntropy.begin(), sectionEntropy.end());
    sectionData.MinEntropy = *std::min_element(sectionEntropy.begin(), sectionEntropy.end());
    sectionData.MeanEntropy = trunc(std::accumulate(sectionEntropy.begin(), sectionEntropy.end(), 0.0) / sectionEntropy.size());
}

void PEFileAnalyser::readDataDirectory() {
    // Move to Data Directory position
    file.seekg(dosHeader.e_lfanew + sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER) + coffHeader.SizeOfOptionalHeader + sizeof(IMAGE_SECTION_HEADER) * coffHeader.NumberOfSections);
    file.read(reinterpret_cast<char*>(&dataDirectory), sizeof(IMAGE_DATA_DIRECTORY));
}

// void PEFileAnalyser::readExportDirectory() {
//     // Move to Export Directory position
//     file.seekg(dataDirectory.ExportTable, std::ios::beg);
//     file.read(reinterpret_cast<char*>(&exportDirectory), sizeof(IMAGE_EXPORT_DIRECTORY));
// }

// void PEFileAnalyser::readImportDirectory() {
//     // Move to Import Directory position
//     file.seekg(dataDirectory.ImportTable, std::ios::beg);
//     file.read(reinterpret_cast<char*>(&importDescriptor), sizeof(IMAGE_IMPORT_DESCRIPTOR));

//     for (int i = 0; i < importDescriptor.ForwarderChain; ++i) {
//         IMAGE_IMPORT_BY_NAME importByNameEntry;
//         file.seekg(dataDirectory.ImportTable + sizeof(IMAGE_IMPORT_BY_NAME) * i);
//         file.read(reinterpret_cast<char*>(&importByNameEntry), sizeof(IMAGE_IMPORT_BY_NAME));
//         importByName.push_back(importByNameEntry);
//     }
// }

// void PEFileAnalyser::countImportsAndExports() {
//     numberOfImports = 0;
//     numberOfExports = 0;

//     std::ifstream f(filePath, std::ios::binary);

//     f.seekg(dataDirectory.ImportTable, std::ios::beg);
//     f.read(reinterpret_cast<char*>(&importDescriptor), sizeof(IMAGE_IMPORT_DESCRIPTOR));

//     for (int i = 0; i < importDescriptor.ForwarderChain; ++i) {
//         IMAGE_IMPORT_BY_NAME importByNameEntry;
//         f.seekg(dataDirectory.ImportTable + sizeof(IMAGE_IMPORT_BY_NAME) * i);
//         f.read(reinterpret_cast<char*>(&importByNameEntry), sizeof(IMAGE_IMPORT_BY_NAME));
//         importByName.push_back(importByNameEntry);
//     }

//     // Read the import directory entries
//     std::vector<IMAGE_IMPORT_DESCRIPTOR> importDirectoryEntries;
//     for (int i = 0; i < importDescriptor.Name; ++i) {
//         IMAGE_IMPORT_DESCRIPTOR importDirectoryEntry;
//         f.seekg(dataDirectory.ImportTable + sizeof(IMAGE_IMPORT_DESCRIPTOR) * i);
//         f.read(reinterpret_cast<char*>(&importDirectoryEntry), sizeof(IMAGE_IMPORT_DESCRIPTOR));
//         importDirectoryEntries.push_back(importDirectoryEntry);
//     }

//     // Read the import by name directory
//     std::vector<IMAGE_IMPORT_BY_NAME> importByNameDirectory;
//     for (int i = 0; i < importDescriptor.ForwarderChain; ++i) {
//         IMAGE_IMPORT_BY_NAME importByNameEntry;
//         f.seekg(dataDirectory.ImportTable + sizeof(IMAGE_IMPORT_BY_NAME) * i);
//         f.read(reinterpret_cast<char*>(&importByNameEntry), sizeof(IMAGE_IMPORT_BY_NAME));
//         importByNameDirectory.push_back(importByNameEntry);
//     }

//     int numberOfImports = 0;
//     for (int i=0; i < importByNameDirectory.size(); i++) {
//         if (importDescriptor.Characteristics != 0) {
//             std::cout << importDescriptor.Characteristics << std::endl;
//             importDirectoryEntries.push_back(importDescriptor);
//             numberOfImports++;
//         }
//         f.seekg(dataDirectory.ImportTable + (i * sizeof(IMAGE_IMPORT_DESCRIPTOR)));
//         f.read(reinterpret_cast<char*>(&importDescriptor), sizeof(IMAGE_IMPORT_DESCRIPTOR));
//     }

//     std::cout << "Total Import Entries: " << numberOfImports << "/" << importByName.size() << std::endl;

//     // Read the export directory entries
//     std::vector<IMAGE_EXPORT_DIRECTORY> exportDirectoryEntries;
//     for (int i = 0; i < exportDirectory.NumberOfFunctions; ++i) {
//         IMAGE_EXPORT_DIRECTORY exportDirectoryEntry;
//         f.seekg(dataDirectory.ExportTable + sizeof(IMAGE_EXPORT_DIRECTORY) * i);
//         f.read(reinterpret_cast<char*>(&exportDirectoryEntry), sizeof(IMAGE_EXPORT_DIRECTORY));
//         exportDirectoryEntries.push_back(exportDirectoryEntry);
//     }

//     int numberOfExports = 0;
//     for (int i=0; i < exportDirectory.NumberOfFunctions; i++) {
//         if (exportDirectory.NumberOfFunctions != 0) {
//             std::cout << exportDirectory.NumberOfFunctions << std::endl;
//             exportDirectoryEntries.push_back(exportDirectory);
//             numberOfExports++;
//         }
//         f.seekg(dataDirectory.ExportTable + (i * sizeof(IMAGE_EXPORT_DIRECTORY)));
//         f.read(reinterpret_cast<char*>(&exportDirectory), sizeof(IMAGE_EXPORT_DIRECTORY));
//     }

//     std::cout << "Total Export Entries: " << numberOfExports << std::endl;
// }

std::vector<std::string> PEFileAnalyser::getKeys(const IMAGE_DOS_HEADER & dosHeader) {
    return {
        "e_magic",
        "e_cblp",
        "e_cp",
        "e_crlc",
        "e_cparhdr",
        "e_minalloc",
        "e_maxalloc",
        "e_ss",
        "e_sp",
        "e_csum",
        "e_ip",
        "e_cs",
        "e_lfarlc",
        "e_ovno",
        "e_oemid",
        "e_oeminfo",
        "e_lfanew"
    };
}

std::vector<std::string> PEFileAnalyser::getKeys(const IMAGE_OPTIONAL_HEADER& optionalHeader) {
    return {
        "Magic",
        "MajorLinkerVersion",
        "MinorLinkerVersion",
        "SizeOfCode",
        "SizeOfInitializedData",
        "SizeOfUninitializedData",
        "AddressOfEntryPoint",
        "BaseOfCode",
        "BaseOfData",
        "ImageBase",
        "SectionAlignment",
        "FileAlignment",
        "MajorOperatingSystemVersion",
        "MinorOperatingSystemVersion",
        "MajorImageVersion",
        "MinorImageVersion",
        "MajorSubsystemVersion",
        "MinorSubsystemVersion",
        "Win32VersionValue",
        "SizeOfImage",
        "SizeOfHeaders",
        "CheckSum",
        "Subsystem",
        "DllCharacteristics",
        "SizeOfStackReserve",
        "SizeOfStackCommit",
        "SizeOfHeapReserve",
        "SizeOfHeapCommit",
        "LoaderFlags",
        "NumberOfRvaAndSizes"
    };
}

std::vector<std::string> PEFileAnalyser::getKeys(const IMAGE_SECTION_DATA& sectionData) {
    return {
        "MaxVirtualSize",
        "MinVirtualSize",
        "MeanVirtualSize",
        "MaxVirtualAddress",
        "MinVirtualAddress",
        "MeanVirtualAddress",
        "MaxSizeOfRawData",
        "MinSizeOfRawData",
        "MeanSizeOfRawData",
        "MaxPointerToRawData",
        "MinPointerToRawData",
        "MeanPointerToRawData",
        "MaxPointerToRelocations",
        "MinPointerToRelocations",
        "MeanPointerToRelocations",
        "MaxPointerToLinenumbers",
        "MinPointerToLinenumbers",
        "MeanPointerToLinenumbers",
        "MaxNumberOfRelocations",
        "MinNumberOfRelocations",
        "MeanNumberOfRelocations",
        "MaxNumberOfLinenumbers",
        "MinNumberOfLinenumbers",
        "MeanNumberOfLinenumbers",
        "MaxCharacteristics",
        "MinCharacteristics",
        "MeanCharacteristics",
        "MaxEntropy",
        "MinEntropy",
        "MeanEntropy"
    };
}

// std::vector<std::string> PEFileAnalyser::getKeys(const IMAGE_DATA_DIRECTORY& imageDataDirectory) {
//     return {
//         "NumberOfImports",
//         "NumberOfExports",
//     };
// }

std::vector<std::string> PEFileAnalyser::getKeys() {
    // Get vector of keys from each struct
    std::vector<std::string> dosHeaderKeys = getKeys(dosHeader);
    std::vector<std::string> optionalHeaderKeys = getKeys(optionalHeader);
    std::vector<std::string> sectionDataKeys = getKeys(sectionData);
    // std::vector<std::string> imageDataKeys = getKeys(dataDirectory);

    std::vector<std::string> keys;
    keys.insert(keys.end(), dosHeaderKeys.begin(), dosHeaderKeys.end());
    keys.insert(keys.end(), optionalHeaderKeys.begin(), optionalHeaderKeys.end());
    keys.insert(keys.end(), sectionDataKeys.begin(), sectionDataKeys.end());
    // keys.insert(keys.end(), imageDataKeys.begin(), imageDataKeys.end());

    return keys;
}

std::vector<double> PEFileAnalyser::getValues(const IMAGE_DOS_HEADER& dosHeader) {
    return {
        static_cast<double>(dosHeader.e_magic),
        static_cast<double>(dosHeader.e_cblp),
        static_cast<double>(dosHeader.e_cp),
        static_cast<double>(dosHeader.e_crlc),
        static_cast<double>(dosHeader.e_cparhdr),
        static_cast<double>(dosHeader.e_minalloc),
        static_cast<double>(dosHeader.e_maxalloc),
        static_cast<double>(dosHeader.e_ss),
        static_cast<double>(dosHeader.e_sp),
        static_cast<double>(dosHeader.e_csum),
        static_cast<double>(dosHeader.e_ip),
        static_cast<double>(dosHeader.e_cs),
        static_cast<double>(dosHeader.e_lfarlc),
        static_cast<double>(dosHeader.e_ovno),
        static_cast<double>(dosHeader.e_oemid),
        static_cast<double>(dosHeader.e_oeminfo),
        static_cast<double>(dosHeader.e_lfanew)
    };
}

std::vector<double> PEFileAnalyser::getValues(const IMAGE_OPTIONAL_HEADER& optionalHeader) {
    return {
        static_cast<double>(optionalHeader.Magic),
        static_cast<double>(optionalHeader.MajorLinkerVersion),
        static_cast<double>(optionalHeader.MinorLinkerVersion),
        static_cast<double>(optionalHeader.SizeOfCode),
        static_cast<double>(optionalHeader.SizeOfInitializedData),
        static_cast<double>(optionalHeader.SizeOfUninitializedData),
        static_cast<double>(optionalHeader.AddressOfEntryPoint),
        static_cast<double>(optionalHeader.BaseOfCode),
        static_cast<double>(optionalHeader.BaseOfData),
        static_cast<double>(optionalHeader.ImageBase),
        static_cast<double>(optionalHeader.SectionAlignment),
        static_cast<double>(optionalHeader.FileAlignment),
        static_cast<double>(optionalHeader.MajorOperatingSystemVersion),
        static_cast<double>(optionalHeader.MinorOperatingSystemVersion),
        static_cast<double>(optionalHeader.MajorImageVersion),
        static_cast<double>(optionalHeader.MinorImageVersion),
        static_cast<double>(optionalHeader.MajorSubsystemVersion),
        static_cast<double>(optionalHeader.MinorSubsystemVersion),
        static_cast<double>(optionalHeader.Win32VersionValue),
        static_cast<double>(optionalHeader.SizeOfImage),
        static_cast<double>(optionalHeader.SizeOfHeaders),
        static_cast<double>(optionalHeader.CheckSum),
        static_cast<double>(optionalHeader.Subsystem),
        static_cast<double>(optionalHeader.DllCharacteristics),
        static_cast<double>(optionalHeader.SizeOfStackReserve),
        static_cast<double>(optionalHeader.SizeOfStackCommit),
        static_cast<double>(optionalHeader.SizeOfHeapReserve),
        static_cast<double>(optionalHeader.SizeOfHeapCommit),
        static_cast<double>(optionalHeader.LoaderFlags),
        static_cast<double>(optionalHeader.NumberOfRvaAndSizes)
    };
}

std::vector<double> PEFileAnalyser::getValues(const IMAGE_SECTION_DATA& sectionData) {
    return {
        static_cast<double>(sectionData.MaxVirtualSize),
        static_cast<double>(sectionData.MinVirtualSize),
        static_cast<double>(sectionData.MeanVirtualSize),
        static_cast<double>(sectionData.MaxVirtualAddress),
        static_cast<double>(sectionData.MinVirtualAddress),
        static_cast<double>(sectionData.MeanVirtualAddress),
        static_cast<double>(sectionData.MaxSizeOfRawData),
        static_cast<double>(sectionData.MinSizeOfRawData),
        static_cast<double>(sectionData.MeanSizeOfRawData),
        static_cast<double>(sectionData.MaxPointerToRawData),
        static_cast<double>(sectionData.MinPointerToRawData),
        static_cast<double>(sectionData.MeanPointerToRawData),
        static_cast<double>(sectionData.MaxPointerToRelocations),
        static_cast<double>(sectionData.MinPointerToRelocations),
        static_cast<double>(sectionData.MeanPointerToRelocations),
        static_cast<double>(sectionData.MaxPointerToLinenumbers),
        static_cast<double>(sectionData.MinPointerToLinenumbers),
        static_cast<double>(sectionData.MeanPointerToLinenumbers),
        static_cast<double>(sectionData.MaxNumberOfRelocations),
        static_cast<double>(sectionData.MinNumberOfRelocations),
        static_cast<double>(sectionData.MeanNumberOfRelocations),
        static_cast<double>(sectionData.MaxNumberOfLinenumbers),
        static_cast<double>(sectionData.MinNumberOfLinenumbers),
        static_cast<double>(sectionData.MeanNumberOfLinenumbers),
        static_cast<double>(sectionData.MaxCharacteristics),
        static_cast<double>(sectionData.MinCharacteristics),
        static_cast<double>(sectionData.MeanCharacteristics),
        static_cast<double>(sectionData.MaxEntropy),
        static_cast<double>(sectionData.MinEntropy),
        static_cast<double>(sectionData.MeanEntropy)
    };
}

// std::vector<double> PEFileAnalyser::getValues(const IMAGE_DATA_DIRECTORY& imageDataDirectory) {
//     return {
//         static_cast<double>(numberOfImports),
//         static_cast<double>(numberOfExports)
//     };
// }

std::vector<double> PEFileAnalyser::getValues() {
    // Get vector of values from each struct
    std::vector<double> dosHeaderValues = getValues(dosHeader);
    std::vector<double> optionalHeaderValues = getValues(optionalHeader);
    std::vector<double> sectionDataValues = getValues(sectionData);
    // std::vector<double> imageDataValues = getValues(dataDirectory);

    std::vector<double> values;
    values.insert(values.end(), dosHeaderValues.begin(), dosHeaderValues.end());
    values.insert(values.end(), optionalHeaderValues.begin(), optionalHeaderValues.end());
    values.insert(values.end(), sectionDataValues.begin(), sectionDataValues.end());
    // values.insert(values.end(), imageDataValues.begin(), imageDataValues.end());

    return values;
}