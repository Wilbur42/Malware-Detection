#include <vector>
#include <algorithm>
#include <random>
#include <iostream>
#include <memory>
#include <string>
#include <fstream>
#include <sstream>
#include <unordered_set>
#include <unordered_map>
#include <vector>
#include <algorithm>

class Matrix {
private:
    std::vector<std::vector<double>> data;
    int rows;
    int columns;

public:
    Matrix(int rows, int columns) : rows(rows), columns(columns) {
        data.resize(rows, std::vector<double>(columns, 0.0));
    }

    Matrix(const std::vector<std::vector<double>>& data) : data(data) {
        rows = data.size();
        columns = data[0].size();
    }

    int getRows() const {
        return rows;
    }

    int getColumns() const {
        return columns;
    }

    void addRow(const std::vector<double>& row) {
        data.push_back(row);
        rows++;
    }

    void addColumn(const std::vector<double>& column) {
        for (int i = 0; i < rows; i++) {
            data[i].push_back(column[i]);
        }
        columns++;
    }

    void removeRow(int row) {
        data.erase(data.begin() + row);
        rows--;
    }

    void removeColumn(int column) {
        for (int i = 0; i < rows; i++) {
            data[i].erase(data[i].begin() + column);
        }
        columns--;
    }

    std::vector<double>& getRow(int row) {
        return data[row];
    }

    const std::vector<double>& getRow(int row) const {
        return data[row];
    }

    std::vector<double> getColumn(int column) const {
        std::vector<double> columnData(rows);
        for (int i = 0; i < rows; i++) {
            columnData[i] = data[i][column];
        }
        return columnData;
    }

    double& operator()(int row, int column) {
        return data[row][column];
    }

    const double& operator()(int row, int column) const {
        return data[row][column];
    }
};

struct Node {
    int feature;
    double threshold;
    Node* left;
    Node* right;
    int label;

    Node(int feature, double threshold, Node* left, Node* right, int label)
        : feature(feature), threshold(threshold), left(left), right(right), label(label) {}
};

class DecisionTreeClassifier {
private:
    Node* root;
    int max_depth;
    int min_samples_split;
    int max_features;

public:
    DecisionTreeClassifier(int max_depth, int min_samples_split, int max_features)
        : root(nullptr), max_depth(max_depth), min_samples_split(min_samples_split), max_features(max_features) {}

    void fit(const Matrix& X, const std::vector<int>& y) {
        root = buildTree(X, y, 0);
    };

    int predict(const Matrix& X) {
        return traverseTree(root, X, 0);
    }

    void clear() {
        clear(root);
    }

    void clear(Node* node) {
        if (node == nullptr) {
            return;
        }

        clear(node->left);
        clear(node->right);
        delete node;
        node = nullptr;
    }


private:
    Node* buildTree(const Matrix& X, const std::vector<int>& y, int depth) {
        if (depth == max_depth || X.getRows() < min_samples_split) {
            return new Node(-1, -1, nullptr, nullptr, getMostCommonLabel(y));
        }

        std::vector<int> features = getRandomFeatures(X.getColumns());

        std::cout << "0 features size of " << features.size() << std::endl;
        std::cout << "0 X size of " << X.getRows() << std::endl;
        std::cout << "0 y size of " << y.size() << std::endl;

        double best_feature = -1.0;
        double best_threshold = -1.0;
        getBestSplit(X, y, features, best_feature, best_threshold);

        std::cout << "1 split data " << best_feature << " " << best_threshold << std::endl;

        if (best_feature == -1 || best_threshold == -1) {
            return new Node(-1, -1, nullptr, nullptr, getMostCommonLabel(y));
        }

        std::vector<bool> left_mask(X.getRows());
        for (int i = 0; i < X.getRows(); i++) {
            left_mask[i] = X(i, best_feature) < best_threshold;
        }

        std::cout << "2 mask size of " << left_mask.size() << std::endl;

        Matrix left_X(0, 0), right_X(0, 0);
        std::vector<int> left_y, right_y;
        for (int i = 0; i < X.getRows(); i++) {
            if (left_mask[i]) {
                left_X.addRow(X.getRow(i));
                left_y.push_back(y[i]);
            } else {
                right_X.addRow(X.getRow(i));
                right_y.push_back(y[i]);
            }
        }

        std::cout << "3 left size of " << left_y.size() << std::endl;
        std::cout << "3 right size of " << right_y.size() << std::endl;

        if (std::min(left_y.size(), right_y.size()) < min_samples_split) {
            return new Node(-1, -1, nullptr, nullptr, getMostCommonLabel(y));
        }

        Node* subtree = new Node(
            best_feature,
            best_threshold,
            buildTree(left_X, left_y, depth + 1),
            buildTree(right_X, right_y, depth + 1),
            -1
        );

        int errorBeforePruning = getError(X, y, subtree);
        int errorAfterPruning = getError(X, y, new Node(-1, -1, nullptr, nullptr, getMostCommonLabel(y)));

        std::cout << "4 error before " << errorBeforePruning << std::endl;
        std::cout << "4 error after " << errorAfterPruning << std::endl;

        if (errorAfterPruning < errorBeforePruning) {
            return new Node(-1, -1, nullptr, nullptr, getMostCommonLabel(y));
        }

        return subtree;
    }

    int getMostCommonLabel(const std::vector<int>& y) {
        std::vector<int> counts(2, 0);
        for (int label : y) {
            counts[label]++;
        }
        return counts[0] > counts[1] ? 0 : 1;
    }

    std::vector<int> getRandomFeatures(int num_features) {
        std::vector<int> features(num_features);
        for (int i = 0; i < num_features; i++) {
            features[i] = i;
        }

        std::random_device rd;
        std::mt19937 engine(rd());
        std::shuffle(features.begin(), features.end(), engine);

        features.resize(max_features);
        return features;
    }

    void getBestSplit(const Matrix& X, const std::vector<int>& y, const std::vector<int>& features, double& best_feature, double& best_threshold) {
        double best_gini = 1.0;
        for (int feature : features) {
            std::vector<double> thresholds = getThresholds(X, feature);
            for (double threshold : thresholds) {
                double gini = getGini(X, y, feature, threshold);
                if (gini < best_gini) {
                    best_gini = gini;
                    best_feature = feature;
                    best_threshold = threshold;
                }
            }
        }
    }

    std::vector<double> getThresholds(const Matrix& X, int feature) {
        std::unordered_set<double> unique_thresholds;
        for (int i = 0; i < X.getRows(); i++) {
            unique_thresholds.insert(X(i, feature));
        }
        std::vector<double> thresholds(unique_thresholds.begin(), unique_thresholds.end());
        return thresholds;
    }

    double getGini(const Matrix& X, const std::vector<int>& y, int feature, double threshold) {
        int left_count = 0;
        int right_count = 0;
        int left_correct = 0;
        int right_correct = 0;

        for (int i = 0; i < X.getRows(); i++) {
            double value = X(i, feature);
            int label = y[i];

            if (value <= threshold) {
                left_count++;
                if (label == 0)
                    left_correct++;
            } else {
                right_count++;
                if (label == 1)
                    right_correct++;
            }
        }

        double left_gini = 1.0 - std::pow(static_cast<double>(left_correct) / left_count, 2);
        double right_gini = 1.0 - std::pow(static_cast<double>(right_correct) / right_count, 2);

        return (left_gini * left_count + right_gini * right_count) / (left_count + right_count);
    }

    int getError(const Matrix& X, const std::vector<int>& y, Node* node) {
        int error = 0;
        for (int i = 0; i < X.getRows(); i++) {
            if (predictNode(X, i, node) != y[i]) {
                error++;
            }
        }
        return error;
    }

    int predictNode(const Matrix& X, int index, Node* node) {
        if (node->label != -1) {
            return node->label;
        }
        if (X(index, node->feature) < node->threshold) {
            return predictNode(X, index, node->left);
        } else {
            return predictNode(X, index, node->right);
        }
    }

    int traverseTree(Node* node, const Matrix& X, int index) {
        if (node->label != -1) {
            return node->label;
        }
        if (X(index, node->feature) < node->threshold) {
            return traverseTree(node->left, X, index);
        } else {
            return traverseTree(node->right, X, index);
        }
    }
};

class RandomForestClassifier {
private:
    std::vector<std::unique_ptr<DecisionTreeClassifier>> trees;
    int num_trees;
    int max_features;
    int min_samples_split;
    int max_depth;

public:
    RandomForestClassifier(int num_trees, int max_features, int min_samples_split, int max_depth)
        : num_trees(num_trees), max_features(max_features), min_samples_split(min_samples_split), max_depth(max_depth) {}

    void fit(const Matrix& X, const std::vector<int>& y) {
        std::vector<int> bootstrapIndices = getBootstrapIndices(X);

        for (int i = 0; i < num_trees; i++) {
            auto tree = std::make_unique<DecisionTreeClassifier>(max_depth, min_samples_split, max_features);

            std::cout << "Fitting tree " << i + 1 << " / " << num_trees << std::endl;

            Matrix bootstrapX = getBootstrapSamples(X, bootstrapIndices);
            std::vector<int> bootstrapY = getBootstrapSamples(y, bootstrapIndices);

            std::cout << "Bootstrap data size " << bootstrapX.getRows() << std::endl;

            tree->fit(bootstrapX, bootstrapY);

            std::cout << "Tree " << i + 1 << " fitted" << std::endl;

            trees.push_back(std::move(tree));

            // tree->clear();
        }
    }

    std::vector<int> predict(const Matrix& X) {
        std::vector<int> predictions;
        for (int i = 0; i < X.getRows(); i++) {
            std::vector<int> votes(2, 0);
            for (const auto& tree : trees) {
                int label = tree->predict(X);
                votes[label]++;
            }
            int predictedLabel = votes[0] > votes[1] ? 0 : 1;
            predictions.push_back(predictedLabel);
        }
        return predictions;
    }

private:
    std::vector<int> getBootstrapIndices(const Matrix& X) {
        std::vector<int> indices(X.getRows());
        for (int i = 0; i < X.getRows(); i++) {
            indices[i] = i;
        }

        std::random_device rd;
        std::mt19937 engine(rd());
        std::shuffle(indices.begin(), indices.end(), engine);

        return indices;
    }

    Matrix getBootstrapSamples(const Matrix& X, const std::vector<int>& indices) {
        Matrix samples(indices.size(), X.getColumns());

        std::vector<int> sortedIndices = indices;
        std::sort(sortedIndices.begin(), sortedIndices.end());

        for (int i = 0; i < sortedIndices.size(); i++) {
            for (int j = 0; j < X.getColumns(); j++) {
                samples(i, j) = X(sortedIndices[i], j);
            }
        }
        return samples;
    }

    std::vector<int> getBootstrapSamples(const std::vector<int>& data, const std::vector<int>& indices) {
        std::vector<int> samples;

        std::vector<int> sortedIndices = indices;
        std::sort(sortedIndices.begin(), sortedIndices.end());

        for (int index : sortedIndices) {
            samples.push_back(data[index]);
        }
        return samples;
    }
};

std::vector<double> parseLine(const std::string& line, std::vector<int>& ignoreIndexes) {
    std::vector<double> row;
    std::stringstream ss(line);
    std::string cell;
    std::unordered_set<int> ignoreSet(ignoreIndexes.begin(), ignoreIndexes.end());

    int cellIndex = 0;
    while (std::getline(ss, cell, ',')) {
        if (ignoreSet.count(cellIndex) == 0) {
            row.push_back(std::stod(cell));
        }
        ++cellIndex;
    }

    return row;
}

std::vector<std::string> parseHeaderLine(const std::string& line) {
    std::vector<std::string> row;
    std::stringstream ss(line);
    std::string cell;
    while (std::getline(ss, cell, ',')) {
        row.push_back(cell);
    }
    return row;
}

void readCSV(const std::string& filename, std::vector<std::vector<double>>& data) {
    std::ifstream file(filename);
    if (!file.is_open()) {
        throw std::runtime_error("Failed to open file: " + filename);
    }

    std::vector<std::string> ignoreColumns = {"Name", "Parent", "Malware", "Code", "MD5"};
    std::vector<int> ignoreIndexs;

    std::string line;
    std::getline(file, line);
    std::vector<std::string> header = parseHeaderLine(line);

    for (int i = 0; i < header.size(); i++) {
        for (const auto& ignoreColumn : ignoreColumns) {
            if (header[i] == ignoreColumn) {
                ignoreIndexs.push_back(i);
            }
        }
    }

    while (std::getline(file, line)) {
        data.push_back(parseLine(line, ignoreIndexs));
    }
}

std::vector<int> extractLabels(std::vector<std::vector<double>>& data) {
    std::vector<int> labels;
    for (auto& row : data) {
        labels.push_back(row.back());
        row.pop_back();
    }
    return labels;
}

Matrix convertToMatrix(const std::vector<std::vector<double>>& data) {
    Matrix X(data.size(), data[0].size());
    for (int i = 0; i < data.size(); i++) {
        for (int j = 0; j < data[i].size(); j++) {
            X(i, j) = data[i][j];
        }
    }
    return X;
}

std::tuple<std::vector<std::vector<double>>, std::vector<std::vector<double>>> splitData(std::vector<std::vector<double>>& data, double trainRatio) {
    int trainSize = static_cast<int>(data.size() * trainRatio);
    std::vector<std::vector<double>>trainData(data.begin(), data.begin() + trainSize);
    std::vector<std::vector<double>> testData(data.begin() + trainSize, data.end());
    return {trainData, testData};
}

int main() {
    std::vector<std::vector<double>> rawData;

    std::vector<std::vector<double>> benign;
    readCSV("./inc/benign_data.csv", benign);

    std::vector<std::vector<double>> malware;
    readCSV("./inc/malware_data.csv", malware);

    // Randomly shuffle the bengin and malware data
    std::random_device rd;
    std::mt19937 engine(rd());
    std::shuffle(benign.begin(), benign.end(), engine);
    std::shuffle(malware.begin(), malware.end(), engine);

    rawData.insert(rawData.end(), benign.begin(), benign.begin()+1000);
    rawData.insert(rawData.end(), malware.begin(), malware.begin()+1000);

    auto [rawTrainData, rawTestData] = splitData(rawData, 0.8);
    std::vector<int> yTrain = extractLabels(rawTrainData);
    std::vector<int> yTest = extractLabels(rawTestData);

    std::cout << "Training data size: " << rawTrainData.size() << std::endl;

    Matrix XTrain = convertToMatrix(rawTrainData);
    Matrix XTest = convertToMatrix(rawTestData);

    std::cout << "Matrix data size: " << XTrain.getRows() << std::endl;

    RandomForestClassifier model(10, 1, 2, 5);
    model.fit(XTrain, yTrain);

    auto predictions = model.predict(XTest);

    int correct = 0;
    for (int i = 0; i < predictions.size(); i++) {
        if (predictions[i] == yTest[i]) {
            correct++;
        }
    }

    std::cout << "Accuracy: " << correct / static_cast<double>(predictions.size()) << std::endl;

    return 0;
}
