#include <vector>
#include <algorithm>
#include <random>
#include <iostream>
#include <memory>
#include <string>
#include <fstream>
#include <sstream>
#include <unordered_set>

class Matrix;

class Matrix {
private:
    std::vector<std::vector<double>> data;
    int rows;
    int columns;

public:
    Matrix(int rows, int columns) : rows(rows), columns(columns) {
        data.resize(rows, std::vector<double>(columns, 0.0));
    }

    Matrix(const std::vector<std::vector<double>>& data) : data(data) {
        rows = data.size();
        columns = data[0].size();
    }

    int getRows() const {
        return rows;
    }

    int getColumns() const {
        return columns;
    }

    void addRow(const Matrix& X, int row) {
        data.push_back(std::vector<double>(X.getColumns()));
        for (int i = 0; i < X.getColumns(); i++) {
            data.back()[i] = X(row, i);
        }
        rows++;
    }

    void addColumn(const Matrix& X, int column) {
        for (int i = 0; i < X.getRows(); i++) {
            data[i].push_back(X(i, column));
        }
        columns++;
    }

    void removeRow(int row) {
        data.erase(data.begin() + row);
        rows--;
    }

    void removeColumn(int column) {
        for (int i = 0; i < rows; i++) {
            data[i].erase(data[i].begin() + column);
        }
        columns--;
    }

    // concatenate two matrices vertically
    Matrix concatenate(const Matrix& X) {
        for (int i = 0; i < X.getRows(); i++) {
            addRow(X, i);
        }
        return *this;
    }

    double& operator()(int row, int column) {
        return data[row][column];
    }

    const double& operator()(int row, int column) const {
        return data[row][column];
    }
};

struct Node {
    int feature;
    double threshold;
    Node* left;
    Node* right;
    int label;

    Node(int feature, double threshold, Node* left, Node* right, int label)
        : feature(feature), threshold(threshold), left(left), right(right), label(label) {}
};

class DecisionTreeClassifier {
    Node* root;
    int max_depth;
    int min_samples_split;
    int max_features;

public:
    DecisionTreeClassifier(int max_depth, int min_samples_split, int max_features)
        : root(nullptr), max_depth(max_depth), min_samples_split(min_samples_split), max_features(max_features) {}

    void fit(const Matrix& X, const std::vector<int>& y) {
        root = buildTree(X, y, 0);
    };

    int predict(const Matrix& X) {
        return traverseTree(root, X, 0);
    }

private:
    Node* buildTree(const Matrix& X, const std::vector<int>& y, int depth) {
        if (depth == max_depth || X.getRows() < min_samples_split) {
            std::cout << "Max depth reached" << std::endl;
            return new Node(-1, -1, nullptr, nullptr, getMostCommonLabel(y));
        }

        std::cout << "depth: " << depth << std::endl;

        std::vector<int> features = getRandomFeatures(X.getColumns());

        std::cout << "Got features" << std::endl;

        int best_feature = -1;
        int best_threshold = -1;
        getBestSplit(X, y, features, best_feature, best_threshold);

        std::cout << "Got best split" << std::endl;

        if (best_feature == -1 || best_threshold == -1) {
            std::cout << "Returning most common label" << std::endl;
            return new Node(-1, -1, nullptr, nullptr, getMostCommonLabel(y));
        }

        std::vector<bool> left_mask(X.getRows());
        for (int i = 0; i < X.getRows(); i++) {
            left_mask[i] = X(i, best_feature) < best_threshold;
        }

        std::cout << "Got left mask" << std::endl;

        Matrix left_X(0, 0), right_X(0, 0);
        std::vector<int> left_y, right_y;
        for (int i = 0; i < X.getRows(); i++) {
            if (left_mask[i]) {
                left_X.addRow(X, i);
                left_y.push_back(y[i]);
            } else {
                right_X.addRow(X, i);
                right_y.push_back(y[i]);
            }
        }

        std::cout << "Got left and right X and y" << std::endl;

        if (std::min(left_y.size(), right_y.size()) < min_samples_split) {
            std::cout << "Returning most common label" << std::endl;
            return new Node(-1, -1, nullptr, nullptr, getMostCommonLabel(y));
        }

        Node* subtree = new Node(
            best_feature,
            best_threshold,
            buildTree(left_X, left_y, depth + 1),
            buildTree(right_X, right_y, depth + 1),
            -1
        );

        std::cout << "Got subtree" << std::endl;

        int errorBeforePruning = getError(X, y, subtree);
        int errorAfterPruning = getError(X, y, new Node(-1, -1, nullptr, nullptr, getMostCommonLabel(y)));

        std::cout << "Got error" << std::endl;

        if (errorAfterPruning < errorBeforePruning) {
            std::cout << "Returning most common label" << std::endl;
            return new Node(-1, -1, nullptr, nullptr, getMostCommonLabel(y));
        }

        return subtree;
    }

    int getMostCommonLabel(const std::vector<int>& y) {
        std::vector<int> counts(2, 0);
        for (int label : y) {
            counts[label]++;
        }
        return counts[0] > counts[1] ? 0 : 1;
    }

    std::vector<int> getRandomFeatures(int num_features) {
        std::vector<int> features(num_features);
        for (int i = 0; i < num_features; i++) {
            features[i] = i;
        }

        // Shuffle the features vector using random_device and mt19937 engine
        std::random_device rd;
        std::mt19937 engine(rd());
        std::shuffle(features.begin(), features.end(), engine);

        features.resize(max_features);
        return features;
    }

    void getBestSplit(const Matrix& X, const std::vector<int>& y, const std::vector<int>& features, int& best_feature, int& best_threshold) {
        double best_gini = 1.0;
        for (int feature : features) {
            std::cout << "feature: " << feature << std::endl;
            std::vector<double> thresholds = getThresholds(X, feature);
            std::cout << "Got thresholds" << std::endl;
            for (double threshold : thresholds) {
                std::cout << "threshold: " << threshold << std::endl;
                double gini = getGini(X, y, feature, threshold);
                std::cout << "gini: " << gini << std::endl;
                if (gini < best_gini) {
                    best_gini = gini;
                    best_feature = feature;
                    best_threshold = threshold;
                }
            }
        }
    }

    std::vector<double> getThresholds(const Matrix& X, int feature) {
        std::vector<double> thresholds;
        for (int i = 0; i < X.getRows(); i++) {
            thresholds.push_back(X(i, feature));
        }
        std::sort(thresholds.begin(), thresholds.end());
        std::vector<double> unique_thresholds;
        for (int i = 0; i < thresholds.size(); i++) {
            if (i == 0 || thresholds[i] != thresholds[i - 1]) {
                unique_thresholds.push_back(thresholds[i]);
            }
        }
        return unique_thresholds;
    }

    double getGini(const Matrix& X, const std::vector<int>& y, int feature, double threshold) {
        std::cout << X.getRows() << std::endl;
        std::cout << y.size() << std::endl;
        std::vector<int> left_labels, right_labels;
        for (int i = 0; i < X.getRows(); i++) {
            // std::cout << y[i] << std::endl;
            if (X(i, feature) < threshold) {
                left_labels.push_back(y[i]);
            } else {
                right_labels.push_back(y[i]);
            }
        }
        std::cout << "Got left and right labels" << std::endl;
        double left_gini = getGiniImpurity(left_labels);
        std::cout << "Got left gini: " << left_gini << std::endl;
        double right_gini = getGiniImpurity(right_labels);
        std::cout << "Got right gini: " << right_gini << std::endl;
        return (left_gini * left_labels.size() + right_gini* right_labels.size()) / (left_labels.size() + right_labels.size());
    }

    double getGiniImpurity(const std::vector<int>& y) {
        std::vector<int> counts(2, 0);
        for (int label : y) {
            counts[label]++;
        }
        double gini = 1.0;
        for (int count : counts) {
            double prob = static_cast<double>(count) / y.size();
            gini -= prob * prob;
        }
        return gini;
    }

    int getError(const Matrix& X, const std::vector<int>& y, Node* node) {
        int error = 0;
        for (int i = 0; i < X.getRows(); i++) {
            if (predictNode(X, i, node) != y[i]) {
                error++;
            }
        }
        return error;
    }

    int predictNode(const Matrix& X, int index, Node* node) {
        if (node->label != -1) {
            return node->label;
        }
        if (X(index, node->feature) < node->threshold) {
            return predictNode(X, index, node->left);
        } else {
            return predictNode(X, index, node->right);
        }
    }

    int traverseTree(Node* node, const Matrix& X, int index) {
        if (node->label != -1) {
            return node->label;
        }
        if (X(index, node->feature) < node->threshold) {
            return traverseTree(node->left, X, index);
        } else {
            return traverseTree(node->right, X, index);
        }
    }
};

class RandomForestClassifier {
private:
    std::vector<std::unique_ptr<DecisionTreeClassifier>> trees;
    int num_trees;
    int max_features;
    int min_samples_split;
    int max_depth;

public:
    RandomForestClassifier(int num_trees, int max_features, int min_samples_split, int max_depth)
        : num_trees(num_trees), max_features(max_features), min_samples_split(min_samples_split), max_depth(max_depth) {}

    void fit(const Matrix& X, const std::vector<int>& y) {
        std::vector<int> bootstrapIndices = getBootstrapIndices(X);

        std::cout << "Fitting " << num_trees << " trees..." << std::endl;

        for (int i = 0; i < num_trees; i++) {
            auto tree = std::make_unique<DecisionTreeClassifier>(max_depth, min_samples_split, max_features);
            std::cout << "Fitting tree " << i + 1 << "..." << std::endl;

            Matrix bootstrapX = getBootstrapSamples(X, bootstrapIndices);
            std::vector<int> bootstrapY = getBootstrapSamples(y, bootstrapIndices);
            std::cout << "Bootstrapped samples..." << std::endl;

            tree->fit(bootstrapX, bootstrapY);
            std::cout << "Fitted tree " << i + 1 << std::endl;

            trees.push_back(std::move(tree));
            std::cout << "Moved tree " << i + 1 << std::endl;
        }
    }

    std::vector<int> predict(const Matrix& X) {
        std::vector<int> predictions;
        for (int i = 0; i < X.getRows(); i++) {
            std::vector<int> votes(2, 0);
            for (const auto& tree : trees) {
                int label = tree->predict(X);
                votes[label]++;
            }
            int predictedLabel = votes[0] > votes[1] ? 0 : 1;
            predictions.push_back(predictedLabel);
        }
        return predictions;
    }

private:
    std::vector<int> getBootstrapIndices(const Matrix& X) {
        std::vector<int> indices(X.getRows());
        for (int i = 0; i < X.getRows(); i++) {
            indices[i] = i;
        }

        std::random_device rd;
        std::mt19937 engine(rd());
        std::shuffle(indices.begin(), indices.end(), engine);

        return indices;
    }

    Matrix getBootstrapSamples(const Matrix& X, const std::vector<int>& indices) {
        Matrix samples(indices.size(), X.getColumns());

        std::vector<int> sortedIndices = indices;
        std::sort(sortedIndices.begin(), sortedIndices.end());

        for (int i = 0; i < sortedIndices.size(); i++) {
            for (int j = 0; j < X.getColumns(); j++) {
                samples(i, j) = X(sortedIndices[i], j);
            }
        }
        return samples;
    }

    std::vector<int> getBootstrapSamples(const std::vector<int>& data, const std::vector<int>& indices) {
        std::vector<int> samples;

        std::vector<int> sortedIndices = indices;
        std::sort(sortedIndices.begin(), sortedIndices.end());

        for (int index : sortedIndices) {
            samples.push_back(data[index]);
        }
        return samples;
    }

};

std::vector<double> parseLine(const std::string& line, std::vector<int>& ignoreIndexes) {
    std::vector<double> row;
    std::stringstream ss(line);
    std::string cell;

    // Use a std::unordered_set for O(1) lookup
    std::unordered_set<int> ignoreSet(ignoreIndexes.begin(), ignoreIndexes.end());

    int cellIndex = 0;
    while (std::getline(ss, cell, ',')) {
        if (ignoreSet.count(cellIndex) == 0) {
            row.push_back(std::stod(cell));
        }
        ++cellIndex;
    }

    return row;
}

std::vector<std::string> parseHeaderLine(const std::string& line) {
    std::vector<std::string> row;
    std::stringstream ss(line);
    std::string cell;
    while (std::getline(ss, cell, ',')) {
        row.push_back(cell);
    }
    return row;
}

void readCSV(const std::string& filename, std::vector<std::vector<double>>& data) {
    std::ifstream file(filename);
    if (!file.is_open()) {
        throw std::runtime_error("Failed to open file: " + filename);
    }

    std::vector<std::string> ignoreColumns = {"Name", "Parent", "Malware", "Code", "MD5"};
    std::vector<int> ignoreIndexs;

    std::cout << "Reading file: " << filename << std::endl;

    std::string line;
    std::getline(file, line);
    std::vector<std::string> header = parseHeaderLine(line);

    for (int i = 0; i < header.size(); i++) {
        for (const auto& ignoreColumn : ignoreColumns) {
            if (header[i] == ignoreColumn) {
                ignoreIndexs.push_back(i);
            }
        }
    }

    std::cout << "Parsing file..." << std::endl;

    while (std::getline(file, line)) {

        data.push_back(parseLine(line, ignoreIndexs));
    }
}

std::vector<int> extractLabels(std::vector<std::vector<double>>& data) {
    std::vector<int> labels;
    for(auto& row : data) {
        labels.push_back(row.back());
        row.pop_back();
    }
    return labels;
}

Matrix convertToMatrix(const std::vector<std::vector<double>>& data) {
    Matrix X(data.size(), data[0].size());
    for(int i = 0; i < data.size(); i++) {
        for(int j = 0; j < data[i].size(); j++) {
            // std::cout << data[i][j] << std::endl;
            X(i, j) = data[i][j];
        }
    }
    return X;
}

std::tuple<std::vector<std::vector<double>>, std::vector<std::vector<double>>> splitData(std::vector<std::vector<double>>& data, double trainRatio) {
    int trainSize = data.size() * trainRatio;
    std::vector<std::vector<double>> trainData(data.begin(), data.begin() + trainSize);
    std::vector<std::vector<double>> testData(data.begin() + trainSize, data.end());
    return {trainData, testData};
}

int main() {
    std::vector<std::vector<double>> rawData;
    readCSV("./inc/data.csv", rawData);

    // rawData.erase(rawData.begin());

    std::cout << "Got file" << std::endl;

    auto [rawTrainData, rawTestData] = splitData(rawData, 0.8);

    std::vector<int> yTrain = extractLabels(rawTrainData);
    std::vector<int> yTest = extractLabels(rawTestData);

    std::cout << yTrain[1] << std::endl;

    std::cout << "Got labels" << std::endl;

    Matrix XTrain = convertToMatrix(rawTrainData);
    Matrix XTest = convertToMatrix(rawTestData);

    std::cout << "Got train and test data" << std::endl;

    // Output first 5 items of XTrain, yTrain, XTest, yTest
    // std::cout << "XTrain: " << std::endl;
    // for (int i = 0; i < 5; i++) {
    //     for (int j = 0; j < XTrain.getColumns(); j++) {
    //         std::cout << XTrain(i, j) << " ";
    //     }
    // }
    // std::cout << "yTrain: " << std::endl;
    // for (int i = 0; i < 5; i++) {
    //     std::cout << yTrain[i] << std::endl;
    // }
    // std::cout << "XTest: " << std::endl;
    // for (int i = 0; i < 5; i++) {
    //     for (int j = 0; j < XTest.getColumns(); j++) {
    //         std::cout << XTest(i, j) << " ";
    //     }
    // }
    // std::cout << "yTest: " << std::endl;
    // for (int i = 0; i < 5; i++) {
    //     std::cout << yTest[i] << std::endl;
    // }


    RandomForestClassifier model(10, 4, 2, 5);

    std::cout << "created model" << std::endl;

    model.fit(XTrain, yTrain);

    std::cout << "fit model" << std::endl;

    auto predictions = model.predict(XTest);

    return 0;
}