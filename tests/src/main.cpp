#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <random>
#include <cmath>
#include <algorithm>
#include <numeric>
#include <unordered_set>
#include <unordered_map>
#include <ctime>
#include <map>

// Decision Tree Node class
class Node {
public:
    Node* left;
    Node* right;
    int featureIndex;
    double threshold;
    int predictedClass;
    bool isLeaf;

    Node() : left(nullptr), right(nullptr), featureIndex(-1), threshold(0.0),
             predictedClass(-1), isLeaf(false) {}
};

// Decision Tree Classifier class
class DecisionTree {
private:
    Node* root;
    int maxDepth;
    int maxFeatures;
    std::vector<std::vector<double>> sortedFeatures;

public:
    DecisionTree(int maxDepth, int maxFeatures, Node* root = nullptr) : maxDepth(maxDepth), maxFeatures(maxFeatures), root(nullptr) {}

    // Train decision tree
    void train(const std::vector<std::vector<double>>& features, const std::vector<int>& labels) {
        // Features MUST be sorted for this algorithm to work correctly (ascending order)
        root = buildTree(features, labels, 0);
    }

    // Predict class label for a single instance
    int predict(const std::vector<double>& instance) {
        Node* current = root;
        while (current && !current->isLeaf) {
            if (instance[current->featureIndex] <= current->threshold) {
                current = current->left;
            } else {
                current = current->right;
            }
        }
        return current->predictedClass;
    }

    Node* const getRoot() const {
        return this->root;
    }

private:

    // Build decision tree recursively
    Node* buildTree(const std::vector<std::vector<double>>& features, const std::vector<int>& labels, int depth) {
        Node* node = new Node();
        if (depth >= maxDepth || features.empty() || isPure(labels)) {
            node->isLeaf = true;
            if (!labels.empty()) {
                node->predictedClass = getMajorityClass(labels);
            }
        } else {
            std::vector<int> randomFeatureIndex = getRandomFeatures(features[0].size());
            int featureIndex;
            double threshold;
            findBestSplit(features, labels, randomFeatureIndex, featureIndex, threshold);

            node->featureIndex = featureIndex;
            node->threshold = threshold;

            std::vector<std::vector<double>> leftFeatures, rightFeatures;
            std::vector<int> leftLabels, rightLabels;

            // Split data based on threshold
            for (size_t i = 0; i < features.size(); ++i) {
                if (features[i][featureIndex] <= threshold) {
                    leftFeatures.push_back(features[i]);
                    leftLabels.push_back(labels[i]);
                } else {
                    rightFeatures.push_back(features[i]);
                    rightLabels.push_back(labels[i]);
                }
            }

            node->left = buildTree(leftFeatures, leftLabels, depth + 1);
            node->right = buildTree(rightFeatures, rightLabels, depth + 1);
        }
        return node;
    }

    std::vector<int> getRandomFeatures(int num_features) {
        std::vector<int> features(num_features);
        std::iota(features.begin(), features.end(), 0);

        std::random_device rd;
        std::mt19937 g(rd());
        std::shuffle(features.begin(), features.end(), g);

        features.resize(maxFeatures);
        return features;
    }

    // Check if all labels in a set are the same
    bool isPure(const std::vector<int>& labels) {
        if (labels.empty()) {
            return true;
        }
        for (size_t i = 1; i < labels.size(); ++i) {
            if (labels[i] != labels[0]) {
                return false;
            }
        }
        return true;
    }

    // Find the best split point based on Gini impurity
    void findBestSplit(const std::vector<std::vector<double>>& features, const std::vector<int>& labels, const std::vector<int>& randomFeatures,
                       int& bestFeature, double& bestThreshold) {
        double bestGini = std::numeric_limits<double>::max();

        for (size_t featureIndex : randomFeatures) {

            std::vector<double> featureValues;
            for (const auto& instance : features) {
                featureValues.push_back(instance[featureIndex]);
            }

            // As data is pre-sorted, the loop can exit early when the best split is found
            for (size_t i = 0; i < featureValues.size() - 1; ++i) {
                double threshold = (featureValues[i] + featureValues[i + 1]) / 2.0;

                std::vector<int> leftLabels, rightLabels;
                std::vector<int> leftCount(2, 0);
                std::vector<int> rightCount(2, 0);
                double giniLeft = 0.0, giniRight = 0.0;

                for (size_t i = 0; i < features.size(); ++i) {
                    if (features[i][featureIndex] <= threshold) {
                        leftLabels.push_back(labels[i]);
                        leftCount[labels[i]]++;
                    } else {
                        rightLabels.push_back(labels[i]);
                        rightCount[labels[i]]++;
                    }
                }

                int numInstances = leftLabels.size() + rightLabels.size();

                if (!leftLabels.empty()) {
                    for (const auto& count : leftCount) {
                        double classProb = static_cast<double>(count) / leftLabels.size();
                        giniLeft += std::pow(classProb, 2);
                    }
                    giniLeft = 1.0 - giniLeft;
                }

                if (!rightLabels.empty()) {
                    for (const auto& count : rightCount) {
                        double classProb = static_cast<double>(count) / rightLabels.size();
                        giniRight += std::pow(classProb, 2);
                    }
                    giniRight = 1.0 - giniRight;
                }

                double gini = (static_cast<double>(leftLabels.size()) / numInstances) * giniLeft +
                              (static_cast<double>(rightLabels.size()) / numInstances) * giniRight;

                if (gini < bestGini) {
                    bestGini = gini;
                    bestFeature = featureIndex;
                    bestThreshold = threshold;
                } else {
                    // If gini doesn't improve, stop trying for this featureIndex
                    break;
                }
            }
        }
    }

    int getMajorityClass(const std::vector<int>& labels) {
        // Important to execution speed
        std::unordered_map<int, int> classCounts;
        int majorityClass = -1;
        int maxCount = 0;

        for (const auto& label : labels) {
            classCounts[label]++;
            if (classCounts[label] > maxCount) {
                maxCount = classCounts[label];
                majorityClass = label;
            }
        }

        return majorityClass;
    }
};

// Random Forest Classifier class
class RandomForest {
private:
    int numTrees;
    int maxDepth;
    int maxFeatures;
    std::vector<DecisionTree*> trees;

public:
    RandomForest() : numTrees(10), maxDepth(5), maxFeatures(1) {}

    RandomForest(const std::string& filename) : numTrees(10), maxDepth(5), maxFeatures(1) {
        loadModel(filename);
    }

    RandomForest(int numTrees, int maxDepth, int maxFeatures) : numTrees(numTrees), maxDepth(maxDepth), maxFeatures(maxFeatures) {}

    // Train random forest
    void train(const std::vector<std::vector<double>>& features, const std::vector<int>& labels) {

        for (int i = 0; i < numTrees; ++i) {
            clock_t startTime = clock();

            DecisionTree* tree = new DecisionTree(maxDepth, maxFeatures);

            // TODO: Check if sampling with replacement is better
            // std::vector<std::vector<double>> sampledFeatures;
            // std::vector<int> sampledLabels;

            // Randomly sample features and labels
            // for (size_t j = 0; j < features.size(); ++j) {
            //     int index = randomInt(0, features.size() - 1);
            //     sampledFeatures.push_back(features[index]);
            //     sampledLabels.push_back(labels[index]);
            // }

            // tree->train(sampledFeatures, sampledLabels);

            // Training features and labels MUST be sorted
            tree->train(features, labels);
            trees.push_back(tree);

            clock_t endTime = clock();
            double elapsedTime = double(endTime - startTime) / CLOCKS_PER_SEC * 1000.0;

            std::cout << "Trained tree " << i + 1 << ", " << elapsedTime << " ms" << std::endl;
        }
    }

    int predict(const std::vector<double>& instance) {
        std::vector<int> predictions(trees.size());
        for (size_t i = 0; i < trees.size(); ++i) {
            predictions[i] = trees[i]->predict(instance);
        }
        std::vector<int> classCounts(2, 0);
        for (const auto& prediction : predictions) {
            classCounts[prediction]++;
        }
        int maxCount = -1;
        int predictedClass = -1;
        for (size_t i = 0; i < classCounts.size(); ++i) {
            if (classCounts[i] > maxCount) {
                maxCount = classCounts[i];
                predictedClass = i;
            }
        }

        return predictedClass;
    }

    int getNumTrees() {
        return trees.size();
    }

    double calculateAccuracy(const std::vector<std::vector<double>>& testFeatures, const std::vector<int>& testLabels) {
        double correctPredictions = 0;

        for (size_t i = 0; i < testFeatures.size(); ++i) {
            if (this->predict(testFeatures[i]) == testLabels[i]) {
                correctPredictions++;
            }
        }

        std::cout << "Correct predictions: " << correctPredictions << "/" << testFeatures.size() << std::endl;

        return correctPredictions / testFeatures.size();
    }

    void saveModel(const std::string& filename) {
        std::ofstream file(filename, std::ios::binary);
        if (file) {
            // Write the model to the file
            file.write(reinterpret_cast<const char*>(&*this), sizeof(*this));
            file.close();
        } else {
            std::cerr << "Failed to open the file for writing." << std::endl;
        }
    }

    void loadModel(const std::string& filename) {
        std::ifstream file(filename, std::ios::binary);
        if (!file) {
            std::cerr << "Failed to open the file for reading." << std::endl;
            return;
        }

        // Read the size of the data to be read from the file
        file.seekg(0, std::ios::end);
        std::size_t dataSize = file.tellg();
        file.seekg(0, std::ios::beg);

        // Create a temporary buffer to hold the data
        std::vector<char> buffer(dataSize);

        // Read the data from the file into the buffer
        file.read(buffer.data(), dataSize);

        // Check if the read was successful
        if (!file) {
            std::cerr << "Failed to read data from the file." << std::endl;
            return;
        }

        // Assign the loaded model to the current model instance
        *this = *reinterpret_cast<RandomForest*>(buffer.data());

        file.close();
    }

private:

    // Generate a random integer between min and max (inclusive)
    int randomInt(int min, int max) {
        static std::random_device rd;
        static std::mt19937 rng(rd());
        std::uniform_int_distribution<int> uni(min, max);
        return uni(rng);
    }
};

// Helper function to parse a line of CSV file and return the header as a vector of strings
std::vector<std::string> parseHeaderLine(const std::string& line) {
    std::vector<std::string> header;
    std::istringstream ss(line);
    std::string cell;
    while (std::getline(ss, cell, ',')) {
        header.push_back(cell);
    }
    return header;
}

// Helper function to parse a line of CSV file and return the values as a vector of doubles
std::vector<double> parseLine(const std::string& line, const std::vector<int>& ignoreIndexes) {
    std::vector<double> row;
    std::stringstream ss(line);
    std::string cell;
    int cellIndex = 0;
    while (std::getline(ss, cell, ',')) {
        if (std::find(ignoreIndexes.begin(), ignoreIndexes.end(), cellIndex) == ignoreIndexes.end()) {
            row.push_back(std::stod(cell));
        }
        cellIndex++;
    }
    return row;
}

// Load CSV file into a matrix
bool loadCSV(const std::string& filename, std::vector<std::vector<double>>& data, std::vector<int>& labels) {
    std::ifstream file(filename);
    if (!file.is_open()) {
        std::cout << "Failed to open file: " << filename << std::endl;
        return false;
    }

    std::vector<std::string> ignoreColumns = {"Name", "Parent", "Code", "MD5"};
    std::vector<int> ignoreIndexes;

    std::string flagheader = "Malware";
    int flagIndex;

    // Skip the first line (header)
    std::string line;
    std::getline(file, line);
    std::vector<std::string> header = parseHeaderLine(line);

    int numIgnored = 0;
    for (int i = 0; i < header.size(); i++) {
        for (const auto& ignoreColumn : ignoreColumns) {
            if (header[i] == ignoreColumn) {
                ignoreIndexes.push_back(i);
                numIgnored++;
                break;
            }
            if (header[i] == flagheader) {
                flagIndex = i - numIgnored;
                break;
            }
        }
    }

    while (std::getline(file, line)) {
        std::vector<double> row = parseLine(line, ignoreIndexes);

        if (!row.empty()) {
            labels.push_back(row[flagIndex]);
            row.erase(row.begin() + flagIndex);
            row.pop_back();
            data.push_back(row);
        }
    }

    std::cout << "Loaded " << data.size() << " data points from " << filename << std::endl;

    file.close();
    return true;
}

// Split data into train and test sets
void trainTestSplit(const std::vector<std::vector<double>>& allFeatures, const std::vector<int>& allLabels,
               std::vector<std::vector<double>>& trainFeatures, std::vector<int>& trainLabels,
               std::vector<std::vector<double>>& testFeatures, std::vector<int>& testLabels,
               double trainRatio = 0.8) {
    if (allFeatures.size() != allLabels.size()) {
        std::cout << "Mismatch between features and labels!" << std::endl;
        return;
    }

    int numTrainInstances = std::round(allFeatures.size() * trainRatio);

    std::vector<int> indices(allFeatures.size());
    std::iota(indices.begin(), indices.end(), 0);
    std::random_device rd;
    std::mt19937 rng(rd());
    std::shuffle(indices.begin(), indices.end(), rng);

    for (int i = 0; i < numTrainInstances; ++i) {
        trainFeatures.push_back(allFeatures[indices[i]]);
        trainLabels.push_back(allLabels[indices[i]]);
    }

    for (int i = numTrainInstances; i < allFeatures.size(); ++i) {
        testFeatures.push_back(allFeatures[indices[i]]);
        testLabels.push_back(allLabels[indices[i]]);
    }
}

// Sort data ascending along all dimensions
void sortData(std::vector<std::vector<double>>& features, std::vector<int>& labels) {
    std::vector<std::pair<std::vector<double>, int>> data;
    for (size_t i = 0; i < features.size(); ++i) {
        data.push_back(std::make_pair(features[i], labels[i]));
    }

    std::sort(data.begin(), data.end(), [](const std::pair<std::vector<double>, int>& a,
                                           const std::pair<std::vector<double>, int>& b) {
        return a.first < b.first;
    });

    for (size_t i = 0; i < features.size(); ++i) {
        features[i] = data[i].first;
        labels[i] = data[i].second;
    }
}

// Attribute extraction

std::vector<uint8_t> readFileBytes(const std::string& filePath) {
    std::ifstream file(filePath, std::ios::binary);
    if (!file) {
        std::cerr << "Failed to open file: " << filePath << std::endl;
        return {};
    }

    // Get the file size
    file.seekg(0, std::ios::end);
    std::streamsize fileSize = file.tellg();
    file.seekg(0, std::ios::beg);

    // Read the file contents into a vector
    std::vector<uint8_t> fileData(fileSize);
    if (!file.read(reinterpret_cast<char*>(fileData.data()), fileSize)) {
        std::cerr << "Failed to read file: " << filePath << std::endl;
        return {};
    }

    return fileData;
}

typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned long DWORD;
typedef long LONG;

#pragma pack(push, 1)
struct IMAGE_DOS_HEADER {
    WORD e_magic;
    WORD e_cblp;
    WORD e_cp;
    WORD e_crlc;
    WORD e_cparhdr;
    WORD e_minalloc;
    WORD e_maxalloc;
    WORD e_ss;
    WORD e_sp;
    WORD e_csum;
    WORD e_ip;
    WORD e_cs;
    WORD e_lfarlc;
    WORD e_ovno;
    WORD e_res[4];
    WORD e_oemid;
    WORD e_oeminfo;
    WORD e_res2[10];
    LONG e_lfanew;
};

struct IMAGE_FILE_HEADER {
    WORD  Machine;
    WORD  NumberOfSections;
    DWORD TimeDateStamp;
    DWORD PointerToSymbolTable;
    DWORD NumberOfSymbols;
    WORD  SizeOfOptionalHeader;
    WORD  Characteristics;
};

struct IMAGE_OPTIONAL_HEADER {
    WORD  Magic;
    BYTE  MajorLinkerVersion;
    BYTE  MinorLinkerVersion;
    DWORD SizeOfCode;
    DWORD SizeOfInitializedData;
    DWORD SizeOfUninitializedData;
    DWORD AddressOfEntryPoint;
    DWORD BaseOfCode;
    DWORD BaseOfData;
    DWORD ImageBase;
    DWORD SectionAlignment;
    DWORD FileAlignment;
    WORD  MajorOperatingSystemVersion;
    WORD  MinorOperatingSystemVersion;
    WORD  MajorImageVersion;
    WORD  MinorImageVersion;
    WORD  MajorSubsystemVersion;
    WORD  MinorSubsystemVersion;
    DWORD Win32VersionValue;
    DWORD SizeOfImage;
    DWORD SizeOfHeaders;
    DWORD CheckSum;
    WORD  Subsystem;
    WORD  DllCharacteristics;
    DWORD SizeOfStackReserve;
    DWORD SizeOfStackCommit;
    DWORD SizeOfHeapReserve;
    DWORD SizeOfHeapCommit;
    DWORD LoaderFlags;
    DWORD NumberOfRvaAndSizes;
};

#pragma pack(pop) // Restore default packing

template <typename T>
void printAttribute(const std::string& name, const T& value) {
    std::cout << name << ": " << std::dec << value << std::endl;
}

int main() {
    const char* filename = "./inc/main.exe"; // Replace with the path to your PE file

    // Open the PE file in binary mode
    std::ifstream file(filename, std::ios::binary);

    if (!file.is_open()) {
        std::cerr << "Error opening the file: " << filename << std::endl;
        return 1;
    }

    // Read the DOS header
    IMAGE_DOS_HEADER dosHeader;
    file.read(reinterpret_cast<char*>(&dosHeader), sizeof(IMAGE_DOS_HEADER));

    // Check if the file has a valid DOS header
    if (dosHeader.e_magic != 0x5A4D) { // "MZ" in hexadecimal
        std::cerr << "Invalid DOS header signature" << std::endl;
        return 1;
    }

    // Output DOS header attributes
    std::cout << "DOS Header:" << std::endl;
    printAttribute("e_magic", dosHeader.e_magic);
    printAttribute("e_cblp", dosHeader.e_cblp);
    printAttribute("e_cp", dosHeader.e_cp);
    printAttribute("e_crlc", dosHeader.e_crlc);
    printAttribute("e_cparhdr", dosHeader.e_cparhdr);
    printAttribute("e_minalloc", dosHeader.e_minalloc);
    printAttribute("e_maxalloc", dosHeader.e_maxalloc);
    printAttribute("e_ss", dosHeader.e_ss);
    printAttribute("e_sp", dosHeader.e_sp);
    printAttribute("e_csum", dosHeader.e_csum);
    printAttribute("e_ip", dosHeader.e_ip);
    printAttribute("e_cs", dosHeader.e_cs);
    printAttribute("e_lfarlc", dosHeader.e_lfarlc);
    printAttribute("e_ovno", dosHeader.e_ovno);
    printAttribute("e_oemid", dosHeader.e_oemid);
    printAttribute("e_oeminfo", dosHeader.e_oeminfo);
    printAttribute("e_lfanew", dosHeader.e_lfanew);

    // Move to the COFF header position
    file.seekg(dosHeader.e_lfanew + sizeof(DWORD));

    // Read the COFF header
    IMAGE_FILE_HEADER coffHeader;
    file.read(reinterpret_cast<char*>(&coffHeader), sizeof(IMAGE_FILE_HEADER));

    // Output COFF header attributes
    std::cout << "\nCOFF Header:" << std::endl;
    printAttribute("Machine", coffHeader.Machine);
    printAttribute("NumberOfSections", coffHeader.NumberOfSections);
    printAttribute("TimeDateStamp", coffHeader.TimeDateStamp);
    printAttribute("PointerToSymbolTable", coffHeader.PointerToSymbolTable);
    printAttribute("NumberOfSymbols", coffHeader.NumberOfSymbols);
    printAttribute("SizeOfOptionalHeader", coffHeader.SizeOfOptionalHeader);
    printAttribute("Characteristics", coffHeader.Characteristics);

    // Read the optional header
    IMAGE_OPTIONAL_HEADER optionalHeader;
    file.read(reinterpret_cast<char*>(&optionalHeader), sizeof(IMAGE_OPTIONAL_HEADER));

    // Output optional header attributes
    std::cout << "\nOptional Header:" << std::endl;
    printAttribute("Magic", optionalHeader.Magic);
    printAttribute("MajorLinkerVersion", optionalHeader.MajorLinkerVersion);
    printAttribute("MinorLinkerVersion", optionalHeader.MinorLinkerVersion);
    printAttribute("SizeOfCode", optionalHeader.SizeOfCode);
    printAttribute("SizeOfInitializedData", optionalHeader.SizeOfInitializedData);
    printAttribute("SizeOfUninitializedData", optionalHeader.SizeOfUninitializedData);
    printAttribute("AddressOfEntryPoint", optionalHeader.AddressOfEntryPoint);
    printAttribute("BaseOfCode", optionalHeader.BaseOfCode);
    printAttribute("BaseOfData", optionalHeader.BaseOfData);
    printAttribute("ImageBase", optionalHeader.ImageBase);
    printAttribute("SectionAlignment", optionalHeader.SectionAlignment);
    printAttribute("FileAlignment", optionalHeader.FileAlignment);
    printAttribute("MajorOperatingSystemVersion", optionalHeader.MajorOperatingSystemVersion);
    printAttribute("MinorOperatingSystemVersion", optionalHeader.MinorOperatingSystemVersion);
    printAttribute("MajorImageVersion", optionalHeader.MajorImageVersion);
    printAttribute("MinorImageVersion", optionalHeader.MinorImageVersion);
    printAttribute("MajorSubsystemVersion", optionalHeader.MajorSubsystemVersion);
    printAttribute("MinorSubsystemVersion", optionalHeader.MinorSubsystemVersion);
    printAttribute("Win32VersionValue", optionalHeader.Win32VersionValue);
    printAttribute("SizeOfImage", optionalHeader.SizeOfImage);
    printAttribute("SizeOfHeaders", optionalHeader.SizeOfHeaders);
    printAttribute("CheckSum", optionalHeader.CheckSum);
    printAttribute("Subsystem", optionalHeader.Subsystem);
    printAttribute("DllCharacteristics", optionalHeader.DllCharacteristics);
    printAttribute("SizeOfStackReserve", optionalHeader.SizeOfStackReserve);
    printAttribute("SizeOfStackCommit", optionalHeader.SizeOfStackCommit);
    printAttribute("SizeOfHeapReserve", optionalHeader.SizeOfHeapReserve);
    printAttribute("SizeOfHeapCommit", optionalHeader.SizeOfHeapCommit);
    printAttribute("LoaderFlags", optionalHeader.LoaderFlags);
    printAttribute("NumberOfRvaAndSizes", optionalHeader.NumberOfRvaAndSizes);

    file.close();

    return 0;

    std::vector<std::vector<double>> benignFeatures, malwareFeatures, allFeatures, trainFeatures, testFeatures;
    std::vector<int> benignLabels, malwareLabels, allLabels, trainLabels, testLabels;

    // Load data from CSV file
    if (!loadCSV("./inc/benign_data.csv", benignFeatures, benignLabels)) {
        std::cout << "Failed to load CSV file!" << std::endl;
        return 1;
    }

    // Load data from CSV file
    if (!loadCSV("./inc/malware_data.csv", malwareFeatures, malwareLabels)) {
        std::cout << "Failed to load CSV file!" << std::endl;
        return 1;
    }

    int dataPoints = -1;

    // Merge benign and malware data
    if (dataPoints != -1) {
        allFeatures.insert(allFeatures.end(), benignFeatures.begin(), benignFeatures.begin() + dataPoints);
        allFeatures.insert(allFeatures.end(), malwareFeatures.begin(), malwareFeatures.begin() + dataPoints);
        allLabels.insert(allLabels.end(), benignLabels.begin(), benignLabels.begin() + dataPoints);
        allLabels.insert(allLabels.end(), malwareLabels.begin(), malwareLabels.begin() + dataPoints);
    } else {
        allFeatures.insert(allFeatures.end(), benignFeatures.begin(), benignFeatures.end());
        allFeatures.insert(allFeatures.end(), malwareFeatures.begin(), malwareFeatures.end());
        allLabels.insert(allLabels.end(), benignLabels.begin(), benignLabels.end());
        allLabels.insert(allLabels.end(), malwareLabels.begin(), malwareLabels.end());
    }

    std::cout << "allFeatures size: " << allFeatures.size() << std::endl;

    // Split data into train and test sets
    trainTestSplit(allFeatures, allLabels, trainFeatures, trainLabels, testFeatures, testLabels);

    // Training features and labels MUST be sorted
    sortData(trainFeatures, trainLabels);

    clock_t begin = clock();

    // Train the Random Forest
    RandomForest forest(10, 5, 1);
    forest.train(trainFeatures, trainLabels);

    std::cout << "Number of trees: " << forest.getNumTrees() << std::endl;

    clock_t end = clock();
    double elapsed_secs = double(end - begin) / CLOCKS_PER_SEC * 1000.0;
    std::cout << "Training time: " << elapsed_secs << " ms" << std::endl;

    // Evaluate the accuracy of the model
    double accuracy = forest.calculateAccuracy(testFeatures, testLabels);
    std::cout << "Accuracy: " << accuracy << std::endl;

    // Test with a single data point
    std::vector<std::vector<double>> testFeatures2;
    std::vector<int> testLabels2;

    // Load data from CSV file
    if (!loadCSV("./inc/test_data.csv", testFeatures2, testLabels2)) {
        std::cout << "Failed to load CSV file!" << std::endl;
        return 1;
    }

    // Sort test features and labels
    sortData(testFeatures2, testLabels2);

    // Evaluate the accuracy of the model
    double predictedLabel = forest.predict(testFeatures2[0]);
    std::cout << "Prediction: " << predictedLabel << std::endl;

    // Outcome is 1 if the prediction is correct, 0 otherwise
    // Most often the prediction is correct
    // However, sometimes the prediction is incorrect due to the randomness of the algorithm
    // Implementation of methods such as feature importance and out-of-bag error could improve
    // the reliability of the model

    // Save the model to a file
    forest.saveModel("./inc/model.bin");

    std::cout << "Model saved to file" << std::endl;

    // Load the model from a file
    RandomForest forest2("./inc/model.bin");

    std::cout << "Model loaded from file" << std::endl;

    // Evaluate the accuracy of the model
    double accuracy2 = forest2.calculateAccuracy(testFeatures, testLabels);
    std::cout << "Accuracy: " << accuracy2 << std::endl;

    // Evaluate the accuracy of the loaded model
    double prediction2 = forest2.predict(testFeatures2[0]);
    std::cout << "Prediction: " << prediction2 << std::endl;

    return 0;
}
