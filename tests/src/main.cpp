#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <random>
#include <cmath>
#include <algorithm>
#include <numeric>
#include <unordered_set>

// Decision Tree Node class
class Node {
public:
    Node* left;
    Node* right;
    int featureIndex;
    double threshold;
    int predictedClass;
    bool isLeaf;

    Node() : left(nullptr), right(nullptr), featureIndex(-1), threshold(0.0),
             predictedClass(-1), isLeaf(false) {}
};

// Decision Tree Classifier class
class DecisionTree {
private:
    Node* root;
    int maxDepth = 10;
    int maxFeatures = 1;

public:
    DecisionTree(int maxDepth, int maxfeatures) {} // : root(nullptr), maxDepth(maxDepth), maxFeatures(maxFeatures) {}

    // Train decision tree
    void train(const std::vector<std::vector<double>>& features, const std::vector<int>& labels) {
        root = buildTree(features, labels, 0);
    }

    // Predict class label for a single instance
    int predict(const std::vector<double>& instance) {
        Node* current = root;
        while (!current->isLeaf) {
            if (instance[current->featureIndex] <= current->threshold) {
                current = current->left;
            } else {
                current = current->right;
            }
        }
        return current->predictedClass;
    }

private:

    // Build decision tree recursively
    Node* buildTree(const std::vector<std::vector<double>>& features, const std::vector<int>& labels, int depth) {
        if (depth == maxDepth || features.empty() || labels.empty()) {
            return nullptr;
        }

        std::cout << "1 features.size() = " << features.size() << std::endl;

        Node* node = new Node();
        if (isPure(labels)) {
            node->isLeaf = true;
            node->predictedClass = labels[0];
            std::cout << "3 Lead Node, predictedClass = " << node->predictedClass << std::endl;
        } else {
            std::vector<int> randomFeatures = getRandomFeatures(features[0].size());
            int featureIndex;
            double threshold;
            findBestSplit(features, labels, randomFeatures, featureIndex, threshold);

            std::cout << "3 Found best split, featureIndex = " << featureIndex << ", threshold = " << threshold << std::endl;

            node->featureIndex = featureIndex;
            node->threshold = threshold;

            std::vector<std::vector<double>> leftFeatures, rightFeatures;
            std::vector<int> leftLabels, rightLabels;

            splitData(features, labels, featureIndex, threshold, leftFeatures, leftLabels, rightFeatures, rightLabels);

            std::cout << "4 leftFeatures.size() = " << leftFeatures.size() << ", leftLabels.size() = " << leftLabels.size() << std::endl;

            node->left = buildTree(leftFeatures, leftLabels, depth + 1);
            node->right = buildTree(rightFeatures, rightLabels, depth + 1);

            std::cout << "5 rightFeatures.size() = " << rightFeatures.size() << ", rightLabels.size() = " << rightLabels.size() << std::endl;
        }
        return node;
    }

    std::vector<int> getRandomFeatures(int num_features) {
        std::vector<int> features(num_features);
        std::iota(features.begin(), features.end(), 0);

        std::random_device rd;
        std::mt19937 g(rd());
        std::shuffle(features.begin(), features.end(), g);

        std::cout << "features.size() = " << features.size() << std::endl;
        std::cout << "maxFeatures = " << maxFeatures << std::endl;

        features.resize(maxFeatures);
        return features;
    }

    // Check if all labels in a set are the same
    bool isPure(const std::vector<int>& labels) {
        for (size_t i = 1; i < labels.size(); ++i) {
            if (labels[i] != labels[0]) {
                return false;
            }
        }
        return true;
    }

    // Find the best split point based on Gini impurity
    void findBestSplit(const std::vector<std::vector<double>>& features, const std::vector<int>& labels, const std::vector<int>& randomFeatures,
                       int& bestFeature, double& bestThreshold) {
        double bestGini = std::numeric_limits<double>::max();

        // for (size_t featureIndex = 0; featureIndex < features[0].size(); ++featureIndex) {
        //     std::vector<double> featureValues;
        //     for (const auto& instance : features) {
        //         featureValues.push_back(instance[featureIndex]);
        //     }

        //     std::sort(featureValues.begin(), featureValues.end());
        //     for (size_t i = 0; i < featureValues.size() - 1; ++i) {
        //         double threshold = (featureValues[i] + featureValues[i + 1]) / 2.0;

        //         std::vector<std::vector<double>> leftFeatures, rightFeatures;
        //         std::vector<int> leftLabels, rightLabels;

        //         splitData(features, labels, featureIndex, threshold, leftFeatures, leftLabels, rightFeatures, rightLabels);

        //         double gini = calculateGini(leftLabels, rightLabels);
        //         if (gini < bestGini) {
        //             bestGini = gini;
        //             bestFeature = featureIndex;
        //             bestThreshold = threshold;
        //         }
        //     }
        // }
        for (size_t featureIndex : randomFeatures) {
            std::vector<double> featureValues;
            for (const auto& instance : features) {
                featureValues.push_back(instance[featureIndex]);
            }

            std::sort(featureValues.begin(), featureValues.end());
            for (size_t i = 0; i < featureValues.size() - 1; ++i) {
                double threshold = (featureValues[i] + featureValues[i + 1]) / 2.0;

                std::vector<std::vector<double>> leftFeatures, rightFeatures;
                std::vector<int> leftLabels, rightLabels;

                splitData(features, labels, featureIndex, threshold, leftFeatures, leftLabels, rightFeatures, rightLabels);

                double gini = calculateGini(leftLabels, rightLabels);
                if (gini < bestGini) {
                    bestGini = gini;
                    bestFeature = featureIndex;
                    bestThreshold = threshold;
                }
            }
        }
    }

    // Split the dataset based on the split point
    void splitData(const std::vector<std::vector<double>>& features, const std::vector<int>& labels,
                   int featureIndex, double threshold,
                   std::vector<std::vector<double>>& leftFeatures, std::vector<int>& leftLabels,
                   std::vector<std::vector<double>>& rightFeatures, std::vector<int>& rightLabels) {
        for (size_t i = 0; i < features.size(); ++i) {
            if (features[i][featureIndex] <= threshold) {
                leftFeatures.push_back(features[i]);
                leftLabels.push_back(labels[i]);
            } else {
                rightFeatures.push_back(features[i]);
                rightLabels.push_back(labels[i]);
            }
        }
    }

    // Calculate Gini impurity
    double calculateGini(const std::vector<int>& leftLabels, const std::vector<int>& rightLabels) {
        int numInstances = leftLabels.size() + rightLabels.size();
        double giniLeft = 0.0, giniRight = 0.0;

        if (!leftLabels.empty()) {
            std::vector<int> classCounts(getNumClasses(leftLabels), 0);
            for (const auto& label : leftLabels) {
                classCounts[label]++;
            }

            for (const auto& count : classCounts) {
                double classProb = static_cast<double>(count) / leftLabels.size();
                giniLeft += std::pow(classProb, 2);
            }
            giniLeft = 1.0 - giniLeft;
        }

        if (!rightLabels.empty()) {
            std::vector<int> classCounts(getNumClasses(rightLabels), 0);
            for (const auto& label : rightLabels) {
                classCounts[label]++;
            }

            for (const auto& count : classCounts) {
                double classProb = static_cast<double>(count) / rightLabels.size();
                giniRight += std::pow(classProb, 2);
            }
            giniRight = 1.0 - giniRight;
        }

        double gini = (static_cast<double>(leftLabels.size()) / numInstances) * giniLeft
                      + (static_cast<double>(rightLabels.size()) / numInstances) * giniRight;

        return gini;
    }

    // Get the number of unique classes in the labels
    int getNumClasses(const std::vector<int>& labels) {
        int numClasses = 0;
        for (const auto& label : labels) {
            if (label > numClasses) {
                numClasses = label;
            }
        }
        return numClasses + 1;
    }
};

// Random Forest Classifier class
class RandomForest {
private:
    int numTrees = 10;
    int maxDepth = 10;
    int maxFeatures = 1;
    std::vector<DecisionTree*> trees;

public:
    RandomForest(int numTrees, int maxDepth, int maxFeatures) {} // : numTrees(numTrees), maxDepth(maxDepth), maxFeatures(maxFeatures) {}

    // Train random forest
    void train(const std::vector<std::vector<double>>& features, const std::vector<int>& labels) {
        for (int i = 0; i < numTrees; ++i) {
            DecisionTree* tree = new DecisionTree(maxDepth, maxFeatures);
            std::vector<std::vector<double>> sampledFeatures;
            std::vector<int> sampledLabels;

            // Sample with replacement
            for (size_t j = 0; j < features.size(); ++j) {
                int index = randomInt(0, features.size() - 1);
                sampledFeatures.push_back(features[index]);
                sampledLabels.push_back(labels[index]);
            }

            tree->train(sampledFeatures, sampledLabels);
            trees.push_back(tree);

            std::cout << "Trained tree " << i + 1 << std::endl;
        }
    }

    // Predict class label for a single instance
    // int predict(const std::vector<double>& instance) {
    //     std::vector<int> predictions(trees.size());
    //     for (size_t i = 0; i < trees.size(); ++i) {
    //         predictions[i] = trees[i]->predict(instance);
    //     }

    //     // Voting for the majority class
    //     std::vector<int> classCounts(getNumClasses(predictions), 0);
    //     for (const auto& prediction : predictions) {
    //         classCounts[prediction]++;
    //     }

    //     int maxCount = -1;
    //     int predictedClass = -1;
    //     for (size_t i = 0; i < classCounts.size(); ++i) {
    //         if (classCounts[i] > maxCount) {
    //             maxCount = classCounts[i];
    //             predictedClass = i;
    //         }
    //     }

    //     return predictedClass;
    // }

    int predict(const std::vector<double>& instance) {
        std::vector<int> predictions(trees.size());
        for (size_t i = 0; i < trees.size(); ++i) {
            predictions[i] = trees[i]->predict(instance);
        }
        std::vector<int> classCounts(getNumClasses(predictions), 0);
        for (const auto& prediction : predictions) {
            classCounts[prediction]++;
        }
        int maxCount = -1;
        int predictedClass = -1;
        for (size_t i = 0; i < classCounts.size(); ++i) {
            if (classCounts[i] > maxCount) {
                maxCount = classCounts[i];
                predictedClass = i;
            }
        }

        return predictedClass;
    }


    int getNumTrees() {
        return trees.size();
    }

private:

    // Generate a random integer between min and max (inclusive)
    int randomInt(int min, int max) {
        static std::random_device rd;
        static std::mt19937 rng(rd());
        std::uniform_int_distribution<int> uni(min, max);
        return uni(rng);
    }

    // Get the number of unique classes in the labels
    int getNumClasses(const std::vector<int>& labels) {
        int numClasses = 0;
        for (const auto& label : labels) {
            if (label > numClasses) {
                numClasses = label;
            }
        }
        return numClasses + 1;
    }
};

std::vector<std::string> parseHeaderLine(const std::string& line) {
    std::vector<std::string> row;
    std::stringstream ss(line);
    std::string cell;
    while (std::getline(ss, cell, ',')) {
        row.push_back(cell);
    }
    return row;
}

std::vector<double> parseLine(const std::string& line, const std::vector<int>& ignoreIndexes) {
    std::vector<double> row;
    std::stringstream ss(line);
    std::string cell;
    std::unordered_set<int> ignoreSet(ignoreIndexes.begin(), ignoreIndexes.end());

    int cellIndex = 0;
    while (std::getline(ss, cell, ',')) {
        if (ignoreSet.count(cellIndex) == 0) {
            row.push_back(std::stod(cell));
        }
        ++cellIndex;
    }

    return row;
}

// Load CSV file into a matrix
bool loadCSV(const std::string& filename, std::vector<std::vector<double>>& data, std::vector<int>& labels) {
    std::ifstream file(filename);
    if (!file.is_open()) {
        std::cout << "Failed to open file: " << filename << std::endl;
        return false;
    }

    std::vector<std::string> ignoreColumns = {"Name", "Parent", "Malware", "Code", "MD5"};
    std::vector<int> ignoreIndexes;

    // Skip the first line (header)
    std::string line;
    std::getline(file, line);
    std::vector<std::string> header = parseHeaderLine(line);

    for (int i = 0; i < header.size(); i++) {
        for (const auto& ignoreColumn : ignoreColumns) {
            if (header[i] == ignoreColumn) {
                ignoreIndexes.push_back(i);
                break;
            }
        }
    }

    std::cout << "Header size: " << header.size() << std::endl;

    std::cout << "Loading data from " << filename << std::endl;

    while (std::getline(file, line)) {
        std::vector<double> row = parseLine(line, ignoreIndexes);

        if (!row.empty()) {
            labels.push_back(static_cast<int>(row.back()));
            row.pop_back();
            data.push_back(row);
        }
    }

    std::cout << "Loaded " << data.size() << " data points from " << filename << std::endl;

    file.close();
    return true;
}

// Split data into train and test sets
void splitData(const std::vector<std::vector<double>>& allFeatures, const std::vector<int>& allLabels,
               std::vector<std::vector<double>>& trainFeatures, std::vector<int>& trainLabels,
               std::vector<std::vector<double>>& testFeatures, std::vector<int>& testLabels,
               double trainRatio = 0.8) {
    if (allFeatures.size() != allLabels.size()) {
        std::cout << "Mismatch between features and labels!" << std::endl;
        return;
    }

    int numTrainInstances = std::round(allFeatures.size() * trainRatio);

    std::vector<int> indices(allFeatures.size());
    std::iota(indices.begin(), indices.end(), 0);
    std::random_device rd;
    std::mt19937 rng(rd());
    std::shuffle(indices.begin(), indices.end(), rng);

    for (int i = 0; i < numTrainInstances; ++i) {
        trainFeatures.push_back(allFeatures[indices[i]]);
        trainLabels.push_back(allLabels[indices[i]]);
    }

    for (int i = numTrainInstances; i < allFeatures.size(); ++i) {
        testFeatures.push_back(allFeatures[indices[i]]);
        testLabels.push_back(allLabels[indices[i]]);
    }
}

// Calculate accuracy of the model
double calculateAccuracy(const std::vector<std::vector<double>>& testFeatures,
                         const std::vector<int>& testLabels, RandomForest& forest) {
    double correctPredictions = 0;

    for (size_t i = 0; i < testFeatures.size(); ++i) {
        for (size_t j = 0; j < testFeatures[i].size(); ++j) {
            std::cout << testFeatures[i][j] << " ";
        }
        std::cout << std::endl;
        int predictedLabel = forest.predict(testFeatures[i]);
        std::cout << "Predicted: " << predictedLabel << ", Actual: " << testLabels[i] << std::endl;
        std::cout << i+1 << "/" << testFeatures.size() << std::endl;
        if (predictedLabel == testLabels[i]) {
            correctPredictions++;
        }
    }

    std::cout << "Correct predictions: " << correctPredictions << "/" << testFeatures.size() << std::endl;

    return correctPredictions / testFeatures.size();
}

int main() {
    std::vector<std::vector<double>> benignFeatures, malwareFeatures, allFeatures, trainFeatures, testFeatures;
    std::vector<int> benignLabels, malwareLabels, allLabels, trainLabels, testLabels;

    // Load data from CSV file
    // if (!loadCSV("./inc/data.csv", allFeatures, allLabels)) {
    //     std::cout << "Failed to load CSV file!" << std::endl;
    //     return 1;
    // }

    // Load data from CSV file
    if (!loadCSV("./inc/benign_data.csv", benignFeatures, benignLabels)) {
        std::cout << "Failed to load CSV file!" << std::endl;
        return 1;
    }

    // Load data from CSV file
    if (!loadCSV("./inc/malware_data.csv", malwareFeatures, malwareLabels)) {
        std::cout << "Failed to load CSV file!" << std::endl;
        return 1;
    }

    // Merge benign and malware data
    allFeatures.insert(allFeatures.end(), benignFeatures.begin(), benignFeatures.begin()+1000);
    allFeatures.insert(allFeatures.end(), malwareFeatures.begin(), malwareFeatures.begin()+1000);
    allLabels.insert(allLabels.end(), benignLabels.begin(), benignLabels.begin()+1000);
    allLabels.insert(allLabels.end(), malwareLabels.begin(), malwareLabels.begin()+1000);

    std::cout << "allFeatures size: " << allFeatures.size() << std::endl;

    // Split data into train and test sets
    splitData(allFeatures, allLabels, trainFeatures, trainLabels, testFeatures, testLabels);

    // Train the Random Forest
    RandomForest forest(10, 5, 1);
    forest.train(trainFeatures, trainLabels);

    std::cout << "Number of trees: " << forest.getNumTrees() << std::endl;

    // Evaluate the accuracy of the model
    double accuracy = calculateAccuracy(testFeatures, testLabels, forest);
    std::cout << "Accuracy: " << accuracy << std::endl;

    return 0;
}
