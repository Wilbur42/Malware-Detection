#include <vector>
#include <algorithm>
#include <random>
#include <iostream>
#include <memory>
#include <string>
#include <fstream>
#include <sstream>

class Matrix;

class Matrix {
private:
    std::vector<std::vector<double>> data;
    int rows;
    int columns;

public:
    Matrix(int rows, int columns) : rows(rows), columns(columns) {
        data.resize(rows, std::vector<double>(columns, 0.0));
    }

    Matrix(const std::vector<std::vector<double>>& data) : data(data) {
        rows = data.size();
        columns = data[0].size();
    }

    int getRows() const {
        return rows;
    }

    int getColumns() const {
        return columns;
    }

    void addRow(const Matrix& X, int row) {
        data.push_back(std::vector<double>(X.getColumns()));
        for (int i = 0; i < X.getColumns(); i++) {
            data.back()[i] = X(row, i);
        }
        rows++;
    }

    void addColumn(const Matrix& X, int column) {
        for (int i = 0; i < X.getRows(); i++) {
            data[i].push_back(X(i, column));
        }
        columns++;
    }

    void removeRow(int row) {
        data.erase(data.begin() + row);
        rows--;
    }

    void removeColumn(int column) {
        for (int i = 0; i < rows; i++) {
            data[i].erase(data[i].begin() + column);
        }
        columns--;
    }

    // concatenate two matrices vertically
    Matrix concatenate(const Matrix& X) {
        for (int i = 0; i < X.getRows(); i++) {
            addRow(X, i);
        }
        return *this;
    }

    double& operator()(int row, int column) {
        return data[row][column];
    }

    const double& operator()(int row, int column) const {
        return data[row][column];
    }
};

struct Node {
    int feature;
    double threshold;
    Node* left;
    Node* right;
    int label;

    Node(int feature, double threshold, Node* left, Node* right, int label)
        : feature(feature), threshold(threshold), left(left), right(right), label(label) {}
};

class DecisionTreeClassifier {
    Node* root;
    int max_depth;
    int min_samples_split;
    int max_features;

public:
    DecisionTreeClassifier(int max_depth, int min_samples_split, int max_features)
        : root(nullptr), max_depth(max_depth), min_samples_split(min_samples_split), max_features(max_features) {}

    void fit(const Matrix& X, const std::vector<int>& y) {
        root = buildTree(X, y, 0);
    };

    int predict(const Matrix& X) {
        return traverseTree(root, X, 0);
    }

private:
    Node* buildTree(const Matrix& X, const std::vector<int>& y, int depth) {
        if (depth == max_depth || X.getRows() < min_samples_split) {
            return new Node(-1, -1, nullptr, nullptr, getMostCommonLabel(y));
        }

        std::vector<int> features = getRandomFeatures(X.getColumns());

        int best_feature = -1;
        int best_threshold = -1;
        getBestSplit(X, y, features, best_feature, best_threshold);

        if (best_feature == -1 || best_threshold == -1) {
            return new Node(-1, -1, nullptr, nullptr, getMostCommonLabel(y));
        }

        std::vector<bool> left_mask(X.getRows());
        for (int i = 0; i < X.getRows(); i++) {
            left_mask[i] = X(i, best_feature) < best_threshold;
        }

        Matrix left_X(0, 0), right_X(0, 0);
        std::vector<int> left_y, right_y;
        for (int i = 0; i < X.getRows(); i++) {
            if (left_mask[i]) {
                left_X.addRow(X, i);
                left_y.push_back(y[i]);
            } else {
                right_X.addRow(X, i);
                right_y.push_back(y[i]);
            }
        }

        if (std::min(left_y.size(), right_y.size()) < min_samples_split) {
            return new Node(-1, -1, nullptr, nullptr, getMostCommonLabel(y));
        }

        Node* subtree = new Node(
            best_feature,
            best_threshold,
            buildTree(left_X, left_y, depth + 1),
            buildTree(right_X, right_y, depth + 1),
            -1
        );

        int errorBeforePruning = getError(X, y, subtree);
        int errorAfterPruning = getError(X, y, new Node(-1, -1, nullptr, nullptr, getMostCommonLabel(y)));

        if (errorAfterPruning < errorBeforePruning) {
            return new Node(-1, -1, nullptr, nullptr, getMostCommonLabel(y));
        }

        return subtree;
    }

    int getMostCommonLabel(const std::vector<int>& y) {
        std::vector<int> counts(2, 0);
        for (int label : y) {
            counts[label]++;
        }
        return counts[0] > counts[1] ? 0 : 1;
    }

    std::vector<int> getRandomFeatures(int num_features) {
        std::vector<int> features(num_features);
        for (int i = 0; i < num_features; i++) {
            features[i] = i;
        }

        // Shuffle the features vector using random_device and mt19937 engine
        std::random_device rd;
        std::mt19937 engine(rd());
        std::shuffle(features.begin(), features.end(), engine);

        features.resize(max_features);
        return features;
    }

    void getBestSplit(const Matrix& X, const std::vector<int>& y, const std::vector<int>& features, int& best_feature, int& best_threshold) {
        double best_gini = 1.0;
        for (int feature : features) {
            std::vector<double> thresholds = getThresholds(X, feature);
            for (double threshold : thresholds) {
                double gini = getGini(X, y, feature, threshold);
                if (gini < best_gini) {
                    best_gini = gini;
                    best_feature = feature;
                    best_threshold = threshold;
                }
            }
        }
    }

    std::vector<double> getThresholds(const Matrix& X, int feature) {
        std::vector<double> thresholds;
        for (int i = 0; i < X.getRows(); i++) {
            thresholds.push_back(X(i, feature));
        }
        std::sort(thresholds.begin(), thresholds.end());
        std::vector<double> unique_thresholds;
        for (int i = 0; i < thresholds.size(); i++) {
            if (i == 0 || thresholds[i] != thresholds[i - 1]) {
                unique_thresholds.push_back(thresholds[i]);
            }
        }
        return unique_thresholds;
    }

    double getGini(const Matrix& X, const std::vector<int>& y, int feature, double threshold) {
        std::vector<int> left_labels, right_labels;
        for (int i = 0; i < X.getRows(); i++) {
            if (X(i, feature) < threshold) {
                left_labels.push_back(y[i]);
            } else {
                right_labels.push_back(y[i]);
            }
        }
        double left_gini = getGiniImpurity(left_labels);
        double right_gini = getGiniImpurity(right_labels);
        return (left_gini * left_labels.size() + right_gini* right_labels.size()) / (left_labels.size() + right_labels.size());
    }

    double getGiniImpurity(const std::vector<int>& y) {
        std::vector<int> counts(2, 0);
        for (int label : y) {
            counts[label]++;
        }
        double gini = 1.0;
        for (int count : counts) {
            double prob = static_cast<double>(count) / y.size();
            gini -= prob * prob;
        }
        return gini;
    }

    int getError(const Matrix& X, const std::vector<int>& y, Node* node) {
        int error = 0;
        for (int i = 0; i < X.getRows(); i++) {
            if (predictNode(X, i, node) != y[i]) {
                error++;
            }
        }
        return error;
    }

    int predictNode(const Matrix& X, int index, Node* node) {
        if (node->label != -1) {
            return node->label;
        }
        if (X(index, node->feature) < node->threshold) {
            return predictNode(X, index, node->left);
        } else {
            return predictNode(X, index, node->right);
        }
    }

    int traverseTree(Node* node, const Matrix& X, int index) {
        if (node->label != -1) {
            return node->label;
        }
        if (X(index, node->feature) < node->threshold) {
            return traverseTree(node->left, X, index);
        } else {
            return traverseTree(node->right, X, index);
        }
    }
};

class RandomForestClassifier {
private:
    std::vector<std::unique_ptr<DecisionTreeClassifier>> trees;
    int num_trees;
    int max_features;
    int min_samples_split;
    int max_depth;

public:
    RandomForestClassifier(int num_trees, int max_features, int min_samples_split, int max_depth)
        : num_trees(num_trees), max_features(max_features), min_samples_split(min_samples_split), max_depth(max_depth) {}

    void fit(const Matrix& X, const std::vector<int>& y) {
        std::vector<int> bootstrapIndices = getBootstrapIndices(X);

        for (int i = 0; i < num_trees; i++) {
            auto tree = std::make_unique<DecisionTreeClassifier>(max_depth, min_samples_split, max_features);
            Matrix bootstrapX = getBootstrapSamples(X, bootstrapIndices);
            std::vector<int> bootstrapY = getBootstrapSamples(y, bootstrapIndices);
            tree->fit(bootstrapX, bootstrapY);
            trees.push_back(std::move(tree));
        }
    }

    std::vector<int> predict(const Matrix& X) {
        std::vector<int> predictions;
        for (int i = 0; i < X.getRows(); i++) {
            std::vector<int> votes(2, 0);
            for (const auto& tree : trees) {
                int label = tree->predict(X);
                votes[label]++;
            }
            int predictedLabel = votes[0] > votes[1] ? 0 : 1;
            predictions.push_back(predictedLabel);
        }
        return predictions;
    }

private:
    std::vector<int> getBootstrapIndices(const Matrix& X) {
        std::vector<int> indices(X.getRows());
        for (int i = 0; i < X.getRows(); i++) {
            indices[i] = i;
        }

        std::random_device rd;
        std::mt19937 engine(rd());
        std::shuffle(indices.begin(), indices.end(), engine);

        return indices;
    }

    Matrix getBootstrapSamples(const Matrix& X, const std::vector<int>& indices) {
        Matrix samples(indices.size(), X.getColumns());
        for (int i = 0; i < indices.size(); i++) {
            for (int j = 0; j < X.getColumns(); j++) {
                samples(i, j) = X(indices[i], j);
            }
        }
        return samples;
    }

    std::vector<int> getBootstrapSamples(const std::vector<int>& data, const std::vector<int>& indices) {
        std::vector<int> samples;
        for (int index : indices) {
            samples.push_back(data[index]);
        }
        return samples;
    }
};

void readCSV(const std::string& filename, std::vector<std::vector<std::string>>& data) {
    std::ifstream file(filename);
    if (!file.is_open()) {
        throw std::runtime_error("Failed to open file: " + filename);
    }

    std::string line;
    while (std::getline(file, line)) {
        std::vector<std::string> row;
        std::stringstream ss(line);
        std::string cell;
        while (std::getline(ss, cell, ',')) {
            row.push_back(cell);
        }
        data.push_back(row);
    }
}

int main() {
    std::cout << "Hello World!" << std::endl;

    std::vector<std::vector<std::string>> benign;
    readCSV("./inc/benign_data.csv", benign);

    std::vector<std::vector<std::string>> malware;
    readCSV("./inc/malware_data.csv", malware);

    std::vector<std::vector<std::string>> data;
    data.insert(data.end(), benign.begin(), benign.end());
    data.insert(data.end(), malware.begin(), malware.end());

    // Output first 5 rows and columns
    for (int i = 0; i < std::min(5, static_cast<int>(data.size())); i++) {
        for (int j = 0; j < std::min(5, static_cast<int>(data[i].size())); j++) {
            std::cout << data[i][j] << " ";
        }
        std::cout << std::endl;
    }
}