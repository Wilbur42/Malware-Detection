#include <string>
#include <vector>
#include <fstream>

typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned long DWORD;
typedef long LONG;
typedef unsigned long long QWORD;

#pragma pack(push, 1)

struct IMAGE_DOS_HEADER {
    WORD e_magic;
    WORD e_cblp;
    WORD e_cp;
    WORD e_crlc;
    WORD e_cparhdr;
    WORD e_minalloc;
    WORD e_maxalloc;
    WORD e_ss;
    WORD e_sp;
    WORD e_csum;
    WORD e_ip;
    WORD e_cs;
    WORD e_lfarlc;
    WORD e_ovno;
    WORD e_res[4];
    WORD e_oemid;
    WORD e_oeminfo;
    WORD e_res2[10];
    LONG e_lfanew;
};

struct IMAGE_FILE_HEADER {
    WORD  Machine;
    WORD  NumberOfSections;
    DWORD TimeDateStamp;
    DWORD PointerToSymbolTable;
    DWORD NumberOfSymbols;
    WORD  SizeOfOptionalHeader;
    WORD  Characteristics;
};

struct IMAGE_OPTIONAL_HEADER {
    WORD  Magic;
    BYTE  MajorLinkerVersion;
    BYTE  MinorLinkerVersion;
    DWORD SizeOfCode;
    DWORD SizeOfInitializedData;
    DWORD SizeOfUninitializedData;
    DWORD AddressOfEntryPoint;
    DWORD BaseOfCode;
    DWORD BaseOfData;
    DWORD ImageBase;
    DWORD SectionAlignment;
    DWORD FileAlignment;
    WORD  MajorOperatingSystemVersion;
    WORD  MinorOperatingSystemVersion;
    WORD  MajorImageVersion;
    WORD  MinorImageVersion;
    WORD  MajorSubsystemVersion;
    WORD  MinorSubsystemVersion;
    DWORD Win32VersionValue;
    DWORD SizeOfImage;
    DWORD SizeOfHeaders;
    DWORD CheckSum;
    WORD  Subsystem;
    WORD  DllCharacteristics;
    DWORD SizeOfStackReserve;
    DWORD SizeOfStackCommit;
    DWORD SizeOfHeapReserve;
    DWORD SizeOfHeapCommit;
    DWORD LoaderFlags;
    DWORD NumberOfRvaAndSizes;
};

struct IMAGE_SECTION_HEADER {
    char  Name[8];
    DWORD VirtualSize;
    DWORD VirtualAddress;
    DWORD SizeOfRawData;
    DWORD PointerToRawData;
    DWORD PointerToRelocations;
    DWORD PointerToLinenumbers;
    WORD  NumberOfRelocations;
    WORD  NumberOfLinenumbers;
    DWORD Characteristics;
};

struct IMAGE_SECTION_DATA {
    int MaxVirtualSize;
    int MinVirtualSize;
    int MeanVirtualSize;
    int MaxVirtualAddress;
    int MinVirtualAddress;
    int MeanVirtualAddress;
    int MaxSizeOfRawData;
    int MinSizeOfRawData;
    int MeanSizeOfRawData;
    int MaxPointerToRawData;
    int MinPointerToRawData;
    int MeanPointerToRawData;
    int MaxPointerToRelocations;
    int MinPointerToRelocations;
    int MeanPointerToRelocations;
    int MaxPointerToLinenumbers;
    int MinPointerToLinenumbers;
    int MeanPointerToLinenumbers;
    int MaxNumberOfRelocations;
    int MinNumberOfRelocations;
    int MeanNumberOfRelocations;
    int MaxNumberOfLinenumbers;
    int MinNumberOfLinenumbers;
    int MeanNumberOfLinenumbers;
    int MaxCharacteristics;
    int MinCharacteristics;
    int MeanCharacteristics;
    double MaxEntropy;
    double MinEntropy;
    double MeanEntropy;
};

struct IMAGE_DATA_DIRECTORY {
    QWORD ExportTable;
    QWORD ImportTable;
};

struct IMAGE_EXPORT_DIRECTORY {
    DWORD Characteristics;
    DWORD TimeDateStamp;
    WORD  MajorVersion;
    WORD  MinorVersion;
    DWORD Name;
    DWORD Base;
    DWORD NumberOfFunctions;
    DWORD NumberOfNames;
    DWORD AddressOfFunctions;
    DWORD AddressOfNames;
    DWORD AddressOfNameOrdinals;
};

struct IMAGE_IMPORT_DESCRIPTOR {
    union {
        DWORD Characteristics;
        DWORD OriginalFirstThunk;
    };
    DWORD TimeDateStamp;
    DWORD ForwarderChain;
    DWORD Name;
    DWORD FirstThunk;
};

struct IMAGE_IMPORT_BY_NAME {
    WORD  Hint;
    char  Name[1];
};

#pragma pack(pop)

class PEFileAnalyser {
private:
    std::ifstream file;
    IMAGE_DOS_HEADER dosHeader;
    IMAGE_FILE_HEADER coffHeader;
    IMAGE_OPTIONAL_HEADER optionalHeader;
    std::vector<IMAGE_SECTION_HEADER> sections;
    IMAGE_SECTION_DATA sectionData;
    IMAGE_DATA_DIRECTORY dataDirectory;
    IMAGE_EXPORT_DIRECTORY exportDirectory;
    IMAGE_IMPORT_DESCRIPTOR importDescriptor;
    int numberOfImports;
    int numberOfExports;

public:
    PEFileAnalyser(const std::string& filePath);

    void analyse(std::vector<std::string> keys, std::vector<double> values);

private:
    bool isValidDOSHeader();

    void readDOSHeader();
    void readCOFFHeader();
    void readOptionalHeader();
    void readSections();
    void readSectionData();
    void readDataDirectory();
    void calculateSectionAttributes();
    void readExportDirectory();
    void readImportDirectory();
    void countImportsAndExports();

    std::vector<uint8_t> readFileBytes();

    std::vector<std::string> getKeys();
    std::vector<std::string> getKeys(const IMAGE_DOS_HEADER & dosHeader);
    std::vector<std::string> getKeys(const IMAGE_OPTIONAL_HEADER & optionalHeader);
    std::vector<std::string> getKeys(const IMAGE_SECTION_DATA& sectionData);
    std::vector<std::string> getKeys(const IMAGE_DATA_DIRECTORY& imageDataDirectory);

    std::vector<double> getValues();
    std::vector<double> getValues(const IMAGE_DOS_HEADER& dosHeader);
    std::vector<double> getValues(const IMAGE_OPTIONAL_HEADER& optionalHeader);
    std::vector<double> getValues(const IMAGE_SECTION_DATA& sectionData);
    std::vector<double> getValues(const IMAGE_DATA_DIRECTORY& imageDataDirectory);
};