#include <string>
#include <vector>
#include <fstream>
#include <filesystem>
#include <numeric>
#include <random>
#include <unordered_set>
#include <sstream>

typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned long DWORD;
typedef long LONG;

#pragma pack(push, 1)

struct IMAGE_DOS_HEADER {
    WORD e_magic;
    WORD e_cblp;
    WORD e_cp;
    WORD e_crlc;
    WORD e_cparhdr;
    WORD e_minalloc;
    WORD e_maxalloc;
    WORD e_ss;
    WORD e_sp;
    WORD e_csum;
    WORD e_ip;
    WORD e_cs;
    WORD e_lfarlc;
    WORD e_ovno;
    WORD e_res[4];
    WORD e_oemid;
    WORD e_oeminfo;
    WORD e_res2[10];
    LONG e_lfanew;
};

struct IMAGE_FILE_HEADER {
    WORD  Machine;
    WORD  NumberOfSections;
    DWORD TimeDateStamp;
    DWORD PointerToSymbolTable;
    DWORD NumberOfSymbols;
    WORD  SizeOfOptionalHeader;
    WORD  Characteristics;
};

struct IMAGE_OPTIONAL_HEADER {
    WORD  Magic;
    BYTE  MajorLinkerVersion;
    BYTE  MinorLinkerVersion;
    DWORD SizeOfCode;
    DWORD SizeOfInitializedData;
    DWORD SizeOfUninitializedData;
    DWORD AddressOfEntryPoint;
    DWORD BaseOfCode;
    DWORD BaseOfData;
    DWORD ImageBase;
    DWORD SectionAlignment;
    DWORD FileAlignment;
    WORD  MajorOperatingSystemVersion;
    WORD  MinorOperatingSystemVersion;
    WORD  MajorImageVersion;
    WORD  MinorImageVersion;
    WORD  MajorSubsystemVersion;
    WORD  MinorSubsystemVersion;
    DWORD Win32VersionValue;
    DWORD SizeOfImage;
    DWORD SizeOfHeaders;
    DWORD CheckSum;
    WORD  Subsystem;
    WORD  DllCharacteristics;
    DWORD SizeOfStackReserve;
    DWORD SizeOfStackCommit;
    DWORD SizeOfHeapReserve;
    DWORD SizeOfHeapCommit;
    DWORD LoaderFlags;
    DWORD NumberOfRvaAndSizes;
};

struct IMAGE_SECTION_HEADER {
    char  Name[8];
    DWORD VirtualSize;
    DWORD VirtualAddress;
    DWORD SizeOfRawData;
    DWORD PointerToRawData;
    DWORD PointerToRelocations;
    DWORD PointerToLinenumbers;
    WORD  NumberOfRelocations;
    WORD  NumberOfLinenumbers;
    DWORD Characteristics;
};

// TODO: Make into a struct of MAX, MIN, MEAN and form in a vector
struct IMAGE_SECTION_DATA {
    int MaxVirtualSize;
    int MinVirtualSize;
    int MeanVirtualSize;
    int MaxVirtualAddress;
    int MinVirtualAddress;
    int MeanVirtualAddress;
    int MaxSizeOfRawData;
    int MinSizeOfRawData;
    int MeanSizeOfRawData;
    int MaxPointerToRawData;
    int MinPointerToRawData;
    int MeanPointerToRawData;
    int MaxPointerToRelocations;
    int MinPointerToRelocations;
    int MeanPointerToRelocations;
    int MaxPointerToLinenumbers;
    int MinPointerToLinenumbers;
    int MeanPointerToLinenumbers;
    int MaxNumberOfRelocations;
    int MinNumberOfRelocations;
    int MeanNumberOfRelocations;
    int MaxNumberOfLinenumbers;
    int MinNumberOfLinenumbers;
    int MeanNumberOfLinenumbers;
    int MaxCharacteristics;
    int MinCharacteristics;
    int MeanCharacteristics;
    double MaxEntropy;
    double MinEntropy;
    double MeanEntropy;
};

#pragma pack(pop)

class PEFileAnalyser {
private:
    std::string filePath;
    std::ifstream file;
    std::vector<uint8_t> fileBytes;
    uint32_t fileSize;
    IMAGE_DOS_HEADER dosHeader;
    IMAGE_FILE_HEADER fileHeader;
    IMAGE_OPTIONAL_HEADER optionalHeader;
    std::vector<IMAGE_SECTION_HEADER> sections;
    IMAGE_SECTION_DATA sectionData;

    // Helper functions...
    std::vector<uint8_t> readFileBytes();
    void readDOSHeader();
    void readFileHeader();
    void readOptionalHeader();
    void readSections();
    void calculateSectionAttributes();
    std::vector<std::string> getKeys(const IMAGE_DOS_HEADER& dosHeader);
    std::vector<std::string> getKeys(const IMAGE_OPTIONAL_HEADER& optionalHeader);
    std::vector<std::string> getKeys(const IMAGE_SECTION_DATA& sectionData);
    std::vector<std::string> getKeys();
    std::vector<double> getValues(const IMAGE_DOS_HEADER& dosHeader);
    std::vector<double> getValues(const IMAGE_OPTIONAL_HEADER& optionalHeader);
    std::vector<double> getValues(const IMAGE_SECTION_DATA& sectionData);
    std::vector<double> getValues();

public:
    PEFileAnalyser(const std::string& filePath);
    void analyse(std::vector<std::string>& keys, std::vector<double>& values);
    bool isValidPEFile();
};

PEFileAnalyser::PEFileAnalyser(const std::string& filePath) : filePath(filePath), file(filePath) {
    if (!file.is_open()) {
        std::cerr << "Failed to open file: " << filePath << std::endl;
        return;
    }

    file.seekg(0, std::ios::end);
    fileSize = file.tellg();
    file.seekg(0, std::ios::beg);

    fileBytes = readFileBytes();
}

std::vector<uint8_t> PEFileAnalyser::readFileBytes() {
    std::ifstream f(filePath, std::ios::binary);
    if (!f.is_open()) {
        std::cerr << "File is not open" << std::endl;
        return {};
    }

    // Read the file contents into a vector
    std::vector<uint8_t> fileData(fileSize);
    f.read(reinterpret_cast<char*>(fileData.data()), fileSize);

    return fileData;
}

void PEFileAnalyser::readDOSHeader() {
    // Move to DOS Header position
    file.seekg(0, std::ios::beg);
    file.read(reinterpret_cast<char*>(&dosHeader), sizeof(IMAGE_DOS_HEADER));
}

void PEFileAnalyser::readFileHeader() {
    // Move to File Header position
    file.seekg(dosHeader.e_lfanew + sizeof(uint32_t));
    file.read(reinterpret_cast<char*>(&fileHeader), sizeof(IMAGE_FILE_HEADER));
}

void PEFileAnalyser::readOptionalHeader() {
    // Move to Optional Header position
    file.seekg(dosHeader.e_lfanew + sizeof(uint32_t) + sizeof(IMAGE_FILE_HEADER));
    file.read(reinterpret_cast<char*>(&optionalHeader), sizeof(IMAGE_OPTIONAL_HEADER));
}

void PEFileAnalyser::readSections() {
    file.seekg(dosHeader.e_lfanew + sizeof(uint32_t) + sizeof(IMAGE_FILE_HEADER) + fileHeader.SizeOfOptionalHeader);

    for (int i = 0; i < fileHeader.NumberOfSections; ++i) {
        IMAGE_SECTION_HEADER section;
        file.read(reinterpret_cast<char*>(&section), sizeof(IMAGE_SECTION_HEADER));
        sections.push_back(section);
    }
}

void PEFileAnalyser::calculateSectionAttributes() {
    std::vector<int> sectionVirtualSize;
    std::vector<int> sectionVirtualAddress;
    std::vector<int> sectionSizeOfRawData;
    std::vector<int> sectionPointerToRawData;
    std::vector<int> sectionPointerToRelocations;
    std::vector<int> sectionPointerToLinenumbers;
    std::vector<int> sectionNumberOfRelocations;
    std::vector<int> sectionNumberOfLinenumbers;
    std::vector<int> sectionCharacteristics;

    for (const IMAGE_SECTION_HEADER& section : sections) {
        sectionVirtualSize.push_back(section.VirtualSize);
        sectionVirtualAddress.push_back(section.VirtualAddress);
        sectionSizeOfRawData.push_back(section.SizeOfRawData);
        sectionPointerToRawData.push_back(section.PointerToRawData);
        sectionPointerToRelocations.push_back(section.PointerToRelocations);
        sectionPointerToLinenumbers.push_back(section.PointerToLinenumbers);
        sectionNumberOfRelocations.push_back(section.NumberOfRelocations);
        sectionNumberOfLinenumbers.push_back(section.NumberOfLinenumbers);
        sectionCharacteristics.push_back(section.Characteristics);
    }

    // Calculate max, min, and mean values for section attributes
    sectionData.MaxVirtualSize = *std::max_element(sectionVirtualSize.begin(), sectionVirtualSize.end());
    sectionData.MaxVirtualAddress = *std::max_element(sectionVirtualAddress.begin(), sectionVirtualAddress.end());
    sectionData.MaxSizeOfRawData = *std::max_element(sectionSizeOfRawData.begin(), sectionSizeOfRawData.end());
    sectionData.MaxPointerToRawData = *std::max_element(sectionPointerToRawData.begin(), sectionPointerToRawData.end());
    sectionData.MaxPointerToRelocations = *std::max_element(sectionPointerToRelocations.begin(), sectionPointerToRelocations.end());
    sectionData.MaxPointerToLinenumbers = *std::max_element(sectionPointerToLinenumbers.begin(), sectionPointerToLinenumbers.end());
    sectionData.MaxNumberOfRelocations = *std::max_element(sectionNumberOfRelocations.begin(), sectionNumberOfRelocations.end());
    sectionData.MaxNumberOfLinenumbers = *std::max_element(sectionNumberOfLinenumbers.begin(), sectionNumberOfLinenumbers.end());
    sectionData.MaxCharacteristics = *std::max_element(sectionCharacteristics.begin(), sectionCharacteristics.end());

    sectionData.MinVirtualSize = *std::min_element(sectionVirtualSize.begin(), sectionVirtualSize.end());
    sectionData.MinVirtualAddress = *std::min_element(sectionVirtualAddress.begin(), sectionVirtualAddress.end());
    sectionData.MinSizeOfRawData = *std::min_element(sectionSizeOfRawData.begin(), sectionSizeOfRawData.end());
    sectionData.MinPointerToRawData = *std::min_element(sectionPointerToRawData.begin(), sectionPointerToRawData.end());
    sectionData.MinPointerToRelocations = *std::min_element(sectionPointerToRelocations.begin(), sectionPointerToRelocations.end());
    sectionData.MinPointerToLinenumbers = *std::min_element(sectionPointerToLinenumbers.begin(), sectionPointerToLinenumbers.end());
    sectionData.MinNumberOfRelocations = *std::min_element(sectionNumberOfRelocations.begin(), sectionNumberOfRelocations.end());
    sectionData.MinNumberOfLinenumbers = *std::min_element(sectionNumberOfLinenumbers.begin(), sectionNumberOfLinenumbers.end());
    sectionData.MinCharacteristics = *std::min_element(sectionCharacteristics.begin(), sectionCharacteristics.end());

    sectionData.MeanVirtualSize = std::accumulate(sectionVirtualSize.begin(), sectionVirtualSize.end(), 0) / static_cast<double>(sectionVirtualSize.size());
    sectionData.MeanVirtualAddress = std::accumulate(sectionVirtualAddress.begin(), sectionVirtualAddress.end(), 0) / static_cast<double>(sectionVirtualAddress.size());
    sectionData.MeanSizeOfRawData = std::accumulate(sectionSizeOfRawData.begin(), sectionSizeOfRawData.end(), 0) / static_cast<double>(sectionSizeOfRawData.size());
    sectionData.MeanPointerToRawData = std::accumulate(sectionPointerToRawData.begin(), sectionPointerToRawData.end(), 0) / static_cast<double>(sectionPointerToRawData.size());
    sectionData.MeanPointerToRelocations = std::accumulate(sectionPointerToRelocations.begin(), sectionPointerToRelocations.end(), 0) / static_cast<double>(sectionPointerToRelocations.size());
    sectionData.MeanPointerToLinenumbers = std::accumulate(sectionPointerToLinenumbers.begin(), sectionPointerToLinenumbers.end(), 0) / static_cast<double>(sectionPointerToLinenumbers.size());
    sectionData.MeanNumberOfRelocations = std::accumulate(sectionNumberOfRelocations.begin(), sectionNumberOfRelocations.end(), 0) / static_cast<double>(sectionNumberOfRelocations.size());
    sectionData.MeanNumberOfLinenumbers = std::accumulate(sectionNumberOfLinenumbers.begin(), sectionNumberOfLinenumbers.end(), 0) / static_cast<double>(sectionNumberOfLinenumbers.size());
    sectionData.MeanCharacteristics = std::accumulate(sectionCharacteristics.begin(), sectionCharacteristics.end(), 0) / static_cast<double>(sectionCharacteristics.size());

    // Calculate entropy of each section
    std::vector<double> sectionEntropy;
    for (const IMAGE_SECTION_HEADER& section : sections) {
        std::vector<uint8_t> sectionBytes(fileBytes.begin() + section.PointerToRawData, fileBytes.begin() + section.PointerToRawData + section.SizeOfRawData);
        std::vector<int> counts(256, 0);
        for (const auto& byte : sectionBytes) {
            counts[byte]++;
        }
        double entropy = 0;
        for (const auto& count : counts) {
            if (count != 0) {
                double probability = static_cast<double>(count) / sectionBytes.size();
                entropy -= probability * std::log2(probability);
            }
        }
        sectionEntropy.push_back(entropy);
    }

    sectionData.MaxEntropy = *std::max_element(sectionEntropy.begin(), sectionEntropy.end());
    sectionData.MinEntropy = *std::min_element(sectionEntropy.begin(), sectionEntropy.end());
    sectionData.MeanEntropy = std::trunc(std::accumulate(sectionEntropy.begin(), sectionEntropy.end(), 0.0) / static_cast<double>(sectionEntropy.size()));
}

void PEFileAnalyser::analyse(std::vector<std::string>& keys, std::vector<double>& values) {

    // Reads DOS Header and checks if it is valid
    if (!isValidPEFile()) {
        std::cerr << "File is not a valid PE file, Invalid DOS header" << std::endl;
        return;
    }

    readFileHeader();
    readOptionalHeader();
    readSections();
    calculateSectionAttributes();

    keys = getKeys();
    values = getValues();

    file.close();
}

bool PEFileAnalyser::isValidPEFile() {
    if (!file.is_open()) {
        std::cerr << "File is not open" << std::endl;
        return false;
    }

    readDOSHeader();
    return dosHeader.e_magic == 0x5A4D;
}

std::vector<std::string> PEFileAnalyser::getKeys(const IMAGE_DOS_HEADER& dosHeader) {
    return {
        "e_magic",
        "e_cblp",
        "e_cp",
        "e_crlc",
        "e_cparhdr",
        "e_minalloc",
        "e_maxalloc",
        "e_ss",
        "e_sp",
        "e_csum",
        "e_ip",
        "e_cs",
        "e_lfarlc",
        "e_ovno",
        "e_oemid",
        "e_oeminfo",
        "e_lfanew"
    };
}

std::vector<std::string> PEFileAnalyser::getKeys(const IMAGE_OPTIONAL_HEADER& optionalHeader) {
    return {
        "Magic",
        "MajorLinkerVersion",
        "MinorLinkerVersion",
        "SizeOfCode",
        "SizeOfInitializedData",
        "SizeOfUninitializedData",
        "AddressOfEntryPoint",
        "BaseOfCode",
        "BaseOfData",
        "ImageBase",
        "SectionAlignment",
        "FileAlignment",
        "MajorOperatingSystemVersion",
        "MinorOperatingSystemVersion",
        "MajorImageVersion",
        "MinorImageVersion",
        "MajorSubsystemVersion",
        "MinorSubsystemVersion",
        "Win32VersionValue",
        "SizeOfImage",
        "SizeOfHeaders",
        "CheckSum",
        "Subsystem",
        "DllCharacteristics",
        "SizeOfStackReserve",
        "SizeOfStackCommit",
        "SizeOfHeapReserve",
        "SizeOfHeapCommit",
        "LoaderFlags",
        "NumberOfRvaAndSizes"
    };
}

std::vector<std::string> PEFileAnalyser::getKeys(const IMAGE_SECTION_DATA& sectionData) {
    return {
        "MaxVirtualSize",
        "MinVirtualSize",
        "MeanVirtualSize",
        "MaxVirtualAddress",
        "MinVirtualAddress",
        "MeanVirtualAddress",
        "MaxSizeOfRawData",
        "MinSizeOfRawData",
        "MeanSizeOfRawData",
        "MaxPointerToRawData",
        "MinPointerToRawData",
        "MeanPointerToRawData",
        "MaxPointerToRelocations",
        "MinPointerToRelocations",
        "MeanPointerToRelocations",
        "MaxPointerToLinenumbers",
        "MinPointerToLinenumbers",
        "MeanPointerToLinenumbers",
        "MaxNumberOfRelocations",
        "MinNumberOfRelocations",
        "MeanNumberOfRelocations",
        "MaxNumberOfLinenumbers",
        "MinNumberOfLinenumbers",
        "MeanNumberOfLinenumbers",
        "MaxCharacteristics",
        "MinCharacteristics",
        "MeanCharacteristics",
        "MaxEntropy",
        "MinEntropy",
        "MeanEntropy"
    };
}

std::vector<std::string> PEFileAnalyser::getKeys() {
    // Get vector of keys from each struct
    std::vector<std::string> dosHeaderKeys = getKeys(dosHeader);
    std::vector<std::string> optionalHeaderKeys = getKeys(optionalHeader);
    std::vector<std::string> sectionDataKeys = getKeys(sectionData);

    std::vector<std::string> keys;
    keys.insert(keys.end(), dosHeaderKeys.begin(), dosHeaderKeys.end());
    keys.insert(keys.end(), optionalHeaderKeys.begin(), optionalHeaderKeys.end());
    keys.insert(keys.end(), sectionDataKeys.begin(), sectionDataKeys.end());

    return keys;
}

std::vector<double> PEFileAnalyser::getValues(const IMAGE_DOS_HEADER& dosHeader) {
    return {
        static_cast<double>(dosHeader.e_magic),
        static_cast<double>(dosHeader.e_cblp),
        static_cast<double>(dosHeader.e_cp),
        static_cast<double>(dosHeader.e_crlc),
        static_cast<double>(dosHeader.e_cparhdr),
        static_cast<double>(dosHeader.e_minalloc),
        static_cast<double>(dosHeader.e_maxalloc),
        static_cast<double>(dosHeader.e_ss),
        static_cast<double>(dosHeader.e_sp),
        static_cast<double>(dosHeader.e_csum),
        static_cast<double>(dosHeader.e_ip),
        static_cast<double>(dosHeader.e_cs),
        static_cast<double>(dosHeader.e_lfarlc),
        static_cast<double>(dosHeader.e_ovno),
        static_cast<double>(dosHeader.e_oemid),
        static_cast<double>(dosHeader.e_oeminfo),
        static_cast<double>(dosHeader.e_lfanew)
    };
}

std::vector<double> PEFileAnalyser::getValues(const IMAGE_OPTIONAL_HEADER& optionalHeader) {
    return {
        static_cast<double>(optionalHeader.Magic),
        static_cast<double>(optionalHeader.MajorLinkerVersion),
        static_cast<double>(optionalHeader.MinorLinkerVersion),
        static_cast<double>(optionalHeader.SizeOfCode),
        static_cast<double>(optionalHeader.SizeOfInitializedData),
        static_cast<double>(optionalHeader.SizeOfUninitializedData),
        static_cast<double>(optionalHeader.AddressOfEntryPoint),
        static_cast<double>(optionalHeader.BaseOfCode),
        static_cast<double>(optionalHeader.BaseOfData),
        static_cast<double>(optionalHeader.ImageBase),
        static_cast<double>(optionalHeader.SectionAlignment),
        static_cast<double>(optionalHeader.FileAlignment),
        static_cast<double>(optionalHeader.MajorOperatingSystemVersion),
        static_cast<double>(optionalHeader.MinorOperatingSystemVersion),
        static_cast<double>(optionalHeader.MajorImageVersion),
        static_cast<double>(optionalHeader.MinorImageVersion),
        static_cast<double>(optionalHeader.MajorSubsystemVersion),
        static_cast<double>(optionalHeader.MinorSubsystemVersion),
        static_cast<double>(optionalHeader.Win32VersionValue),
        static_cast<double>(optionalHeader.SizeOfImage),
        static_cast<double>(optionalHeader.SizeOfHeaders),
        static_cast<double>(optionalHeader.CheckSum),
        static_cast<double>(optionalHeader.Subsystem),
        static_cast<double>(optionalHeader.DllCharacteristics),
        static_cast<double>(optionalHeader.SizeOfStackReserve),
        static_cast<double>(optionalHeader.SizeOfStackCommit),
        static_cast<double>(optionalHeader.SizeOfHeapReserve),
        static_cast<double>(optionalHeader.SizeOfHeapCommit),
        static_cast<double>(optionalHeader.LoaderFlags),
        static_cast<double>(optionalHeader.NumberOfRvaAndSizes)
    };
}

std::vector<double> PEFileAnalyser::getValues(const IMAGE_SECTION_DATA& sectionData) {
    return {
        static_cast<double>(sectionData.MaxVirtualSize),
        static_cast<double>(sectionData.MinVirtualSize),
        static_cast<double>(sectionData.MeanVirtualSize),
        static_cast<double>(sectionData.MaxVirtualAddress),
        static_cast<double>(sectionData.MinVirtualAddress),
        static_cast<double>(sectionData.MeanVirtualAddress),
        static_cast<double>(sectionData.MaxSizeOfRawData),
        static_cast<double>(sectionData.MinSizeOfRawData),
        static_cast<double>(sectionData.MeanSizeOfRawData),
        static_cast<double>(sectionData.MaxPointerToRawData),
        static_cast<double>(sectionData.MinPointerToRawData),
        static_cast<double>(sectionData.MeanPointerToRawData),
        static_cast<double>(sectionData.MaxPointerToRelocations),
        static_cast<double>(sectionData.MinPointerToRelocations),
        static_cast<double>(sectionData.MeanPointerToRelocations),
        static_cast<double>(sectionData.MaxPointerToLinenumbers),
        static_cast<double>(sectionData.MinPointerToLinenumbers),
        static_cast<double>(sectionData.MeanPointerToLinenumbers),
        static_cast<double>(sectionData.MaxNumberOfRelocations),
        static_cast<double>(sectionData.MinNumberOfRelocations),
        static_cast<double>(sectionData.MeanNumberOfRelocations),
        static_cast<double>(sectionData.MaxNumberOfLinenumbers),
        static_cast<double>(sectionData.MinNumberOfLinenumbers),
        static_cast<double>(sectionData.MeanNumberOfLinenumbers),
        static_cast<double>(sectionData.MaxCharacteristics),
        static_cast<double>(sectionData.MinCharacteristics),
        static_cast<double>(sectionData.MeanCharacteristics),
        static_cast<double>(sectionData.MaxEntropy),
        static_cast<double>(sectionData.MinEntropy),
        static_cast<double>(sectionData.MeanEntropy)
    };
}

std::vector<double> PEFileAnalyser::getValues() {
    // Get vector of values from each struct
    std::vector<double> dosHeaderValues = getValues(dosHeader);
    std::vector<double> optionalHeaderValues = getValues(optionalHeader);
    std::vector<double> sectionDataValues = getValues(sectionData);

    std::vector<double> values;
    values.insert(values.end(), dosHeaderValues.begin(), dosHeaderValues.end());
    values.insert(values.end(), optionalHeaderValues.begin(), optionalHeaderValues.end());
    values.insert(values.end(), sectionDataValues.begin(), sectionDataValues.end());

    return values;
}

// Data Handling

// Get features from a single file
void fileAttr(const std::string& filePath, std::vector<std::string>& headers, std::vector<double>& features) {
    PEFileAnalyser file(filePath);
    file.analyse(headers, features);
}

// Helper function to parse a line of CSV file and return the header as a vector of strings
std::vector<std::string> parseHeaderLine(const std::string& line) {
    std::vector<std::string> header;
    std::stringstream ss(line);
    std::string cell;
    while (std::getline(ss, cell, ',')) {
        header.push_back(cell);
    }
    return header;
}

// Helper function to parse a line of CSV file and return the values as a vector of doubles
std::vector<double> parseLine(const std::string& line, const std::vector<int>& ignoreIndices) {
    std::vector<double> row;
    std::stringstream ss(line);
    std::string cell;
    int cellIndex = 0;
    while (std::getline(ss, cell, ',')) {
        if (std::find(ignoreIndices.begin(), ignoreIndices.end(), cellIndex) == ignoreIndices.end()) {
            row.push_back(std::stod(cell));
        }
        cellIndex++;
    }
    return row;
}

// Load CSV file into a matrix
bool loadCSV(const std::string& filename, std::vector<std::vector<double>>& data, std::vector<int>& labels, std::vector<std::string>& header, std::string flagHeader, std::vector<std::string> ignoreColumns={}) {
    std::ifstream file(filename);
    if (!file.is_open()) {
        std::cerr << "Failed to open file: " << filename << std::endl;
        return false;
    }

    // Skip the first line (header)
    std::string line;
    std::getline(file, line);
    std::vector<std::string> tempHeader = parseHeaderLine(line);

    // Find the index of the flag header and ignore columns
    std::vector<int> ignoreIndices;
    int numIgnored = 0;
    int flagIndex = -1;

    for (int i = 0; i < tempHeader.size(); i++) {
        for (const auto& ignoreColumn : ignoreColumns) {
            if (tempHeader[i] == ignoreColumn) {
                ignoreIndices.push_back(i);
                numIgnored++;
                break;
            }
        }
        if (tempHeader[i] == flagHeader) {
            flagIndex = i - numIgnored;
            break;
        }
    }

    // Flag header not found
    if (flagIndex == -1) {
        std::cerr << "Flag header not found: " << flagHeader << std::endl;
        return false;
    }

    // Create header
    for (const auto& h : tempHeader) {
        if (std::find(ignoreColumns.begin(), ignoreColumns.end(), h) == ignoreColumns.end() && h != flagHeader) {
            header.push_back(h);
        }
    }

    // Read the rest of the file to get the data
    while (std::getline(file, line)) {
        std::vector<double> row = parseLine(line, ignoreIndices);

        if (!row.empty()) {
            labels.push_back(row[flagIndex]);
            row.erase(row.begin() + flagIndex);
            row.pop_back();
            data.push_back(row);
        }
    }

    file.close();
    return true;
}

// Sort data ascending along all dimensions
void sortData(std::vector<std::vector<double>>& features, std::vector<int>& labels) {
    std::vector<std::pair<std::vector<double>, int>> data;
    for (size_t i = 0; i < features.size(); ++i) {
        data.push_back(std::make_pair(features[i], labels[i]));
    }

    std::sort(data.begin(), data.end(), [](const std::pair<std::vector<double>, int>& a,
                                           const std::pair<std::vector<double>, int>& b) {
        return a.first < b.first;
    });

    for (size_t i = 0; i < features.size(); ++i) {
        features[i] = data[i].first;
        labels[i] = data[i].second;
    }
}

// Data curation
int randomInt(int min, int max) {
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(min, max);
    return dis(gen);
}

int uniqueCode(std::unordered_set<int>& usedCodes) {
    int code;
    do {
        code = randomInt(10000000, 99999999);
    } while (usedCodes.find(code) != usedCodes.end());

    usedCodes.insert(code);
    return code;
}

std::vector<std::string> getFiles(const std::string& path, const std::vector<std::string>& ignored_folders = {}) {
    std::vector<std::string> files;
    try {
        for (const auto& entry : std::filesystem::directory_iterator(path)) {
            const std::string& element_path = entry.path().string();
            const std::string& element_name = entry.path().filename().string();

            if (std::find(ignored_folders.begin(), ignored_folders.end(), element_name) != ignored_folders.end()) {
                continue;
            }
            if (std::filesystem::is_regular_file(entry.status())) {
                files.push_back(element_path);
            } else if (std::filesystem::is_directory(entry.status())) {
                const std::vector<std::string>& subfiles = getFiles(element_path, ignored_folders);
                files.insert(files.end(), subfiles.begin(), subfiles.end());
            }
        }
    } catch (const std::filesystem::filesystem_error&) {
        return {};
    }
    return files;
}

void saveFileDataFromFolder(std::string folder, std::stringstream dataStream) {

    for (std::string file : getFiles(folder)) {
        std::vector<std::string> headers;
        std::vector<double> features;
        fileAttr(file, headers, features);

        // If empty, add headers
        if (dataStream.str().empty()) {
            for (auto& header : headers) {
                dataStream << header << ",";
            }
            dataStream << "\n" << std::endl;
        }

        // Add features
        for (auto& feature : features) {
            dataStream << feature << ",";
        }
        dataStream << "\n" << std::endl;
    }
}