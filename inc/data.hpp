#include <iostream>
#include <fstream>
#include <vector>
#include <map>
#include <cmath>
#include <algorithm>
#include <numeric>

class PEFileAnalyser {
private:
    std::string filePath;
    std::vector<uint8_t> fileBytes;
    uint32_t fileSize;

    std::map<std::string, double> dosHeader;
    std::map<std::string, double> fileHeader;
    std::map<std::string, double> optionalHeader;
    std::vector<std::map<std::string, double>> sections;
    std::map<std::string, double> sectionData;

    const int fileHeaderSize = 20;

    // Keys for the features
    const std::vector<std::string> keys = {
        // DOS Header
        "e_magic", "e_cblp", "e_cp", "e_crlc", "e_cparhdr", "e_minalloc", "e_maxalloc", "e_ss",
        "e_sp", "e_csum", "e_ip", "e_cs", "e_lfarlc", "e_ovno", "e_oemid", "e_oeminfo", "e_lfanew",

        // Optional Header
        "Magic", "MajorLinkerVersion", "MinorLinkerVersion", "SizeOfCode", "SizeOfInitializedData",
        "SizeOfUninitializedData", "AddressOfEntryPoint", "BaseOfCode", "BaseOfData", "ImageBase",
        "SectionAlignment", "FileAlignment", "MajorOperatingSystemVersion", "MinorOperatingSystemVersion",
        "MajorImageVersion", "MinorImageVersion", "MajorSubsystemVersion", "MinorSubsystemVersion",
        "Win32VersionValue", "SizeOfImage", "SizeOfHeaders", "CheckSum", "Subsystem", "DllCharacteristics",
        "SizeOfStackReserve", "SizeOfStackCommit", "SizeOfHeapReserve", "SizeOfHeapCommit", "LoaderFlags",
        "NumberOfRvaAndSizes",

        // Section Data
        "MaxVirtualSize", "MinVirtualSize", "MeanVirtualSize",
        "MaxVirtualAddress", "MinVirtualAddress", "MeanVirtualAddress",
        "MaxSizeOfRawData", "MinSizeOfRawData", "MeanSizeOfRawData",
        "MaxPointerToRawData", "MinPointerToRawData", "MeanPointerToRawData",
        "MaxPointerToRelocations", "MinPointerToRelocations", "MeanPointerToRelocations",
        "MaxPointerToLinenumbers", "MinPointerToLinenumbers", "MeanPointerToLinenumbers",
        "MaxNumberOfRelocations", "MinNumberOfRelocations", "MeanNumberOfRelocations",
        "MaxNumberOfLinenumbers", "MinNumberOfLinenumbers", "MeanNumberOfLinenumbers",
        "MaxCharacteristics", "MinCharacteristics", "MeanCharacteristics",
        "MaxEntropy", "MinEntropy", "MeanEntropy"
    };


public:
    PEFileAnalyser(const std::string& filePath);
    void analyse(std::vector<std::string>& keys, std::vector<double>& values);
    bool isValidPEFile();

private:
    void readDOSHeader();
    void readFileHeader();
    void readOptionalHeader();
    void readSections();
    void calculateSectionAttributes();
    std::vector<double> getValues();
};

PEFileAnalyser::PEFileAnalyser(const std::string& filePath) : filePath(filePath){
    std::ifstream file(filePath, std::ios::binary);
    if (!file.is_open()) {
        std::cerr << "Failed to open file: " << filePath << std::endl;
        return;
    }

    file.seekg(0, std::ios::end);
    fileSize = file.tellg();
    file.seekg(0, std::ios::beg);

    // Read the file contents into a vector
    fileBytes.clear();
    fileBytes.resize(fileSize);
    file.read(reinterpret_cast<char*>(fileBytes.data()), fileSize);
}

void PEFileAnalyser::readDOSHeader() {
    dosHeader = {
        {"e_magic", fileBytes[0] | fileBytes[1] << 8},
        {"e_cblp", fileBytes[2] | fileBytes[3] << 8},
        {"e_cp", fileBytes[4] | fileBytes[5] << 8},
        {"e_crlc", fileBytes[6] | fileBytes[7] << 8},
        {"e_cparhdr", fileBytes[8] | fileBytes[9] << 8},
        {"e_minalloc", fileBytes[10] | fileBytes[11] << 8},
        {"e_maxalloc", fileBytes[12] | fileBytes[13] << 8},
        {"e_ss", fileBytes[14] | fileBytes[15] << 8},
        {"e_sp", fileBytes[16] | fileBytes[17] << 8},
        {"e_csum", fileBytes[18] | fileBytes[19] << 8},
        {"e_ip", fileBytes[20] | fileBytes[21] << 8},
        {"e_cs", fileBytes[22] | fileBytes[23] << 8},
        {"e_lfarlc", fileBytes[24] | fileBytes[25] << 8},
        {"e_ovno", fileBytes[26] | fileBytes[27] << 8},
        {"e_res0", fileBytes[28] | fileBytes[29] << 8},
        {"e_res1", fileBytes[30] | fileBytes[31] << 8},
        {"e_res2", fileBytes[32] | fileBytes[33] << 8},
        {"e_res3", fileBytes[34] | fileBytes[35] << 8},
        {"e_oemid", fileBytes[36] | fileBytes[37] << 8},
        {"e_oeminfo", fileBytes[38] | fileBytes[39] << 8},
        {"e_res2_0", fileBytes[40] | fileBytes[41] << 8},
        {"e_res2_1", fileBytes[42] | fileBytes[43] << 8},
        {"e_res2_2", fileBytes[44] | fileBytes[45] << 8},
        {"e_res2_3", fileBytes[46] | fileBytes[47] << 8},
        {"e_res2_4", fileBytes[48] | fileBytes[49] << 8},
        {"e_res2_5", fileBytes[50] | fileBytes[51] << 8},
        {"e_res2_6", fileBytes[52] | fileBytes[53] << 8},
        {"e_res2_7", fileBytes[54] | fileBytes[55] << 8},
        {"e_res2_8", fileBytes[56] | fileBytes[57] << 8},
        {"e_res2_9", fileBytes[58] | fileBytes[59] << 8},
        {"e_lfanew", fileBytes[60] | fileBytes[61] << 8 | fileBytes[62] << 16 | fileBytes[63] << 24}
    };
}

void PEFileAnalyser::readFileHeader() {
    // Set offset
    int offset = dosHeader["e_lfanew"] + sizeof(uint32_t);

    fileHeader = {
        {"Machine", fileBytes[offset] | fileBytes[offset + 1] << 8},
        {"NumberOfSections", fileBytes[offset + 2] | fileBytes[offset + 3] << 8},
        {"TimeDateStamp", fileBytes[offset + 4] | fileBytes[offset + 5] << 8 | fileBytes[offset + 6] << 16 | fileBytes[offset + 7] << 24},
        {"PointerToSymbolTable", fileBytes[offset + 8] | fileBytes[offset + 9] << 8 | fileBytes[offset + 10] << 16 | fileBytes[offset + 11] << 24},
        {"NumberOfSymbols", fileBytes[offset + 12] | fileBytes[offset + 13] << 8 | fileBytes[offset + 14] << 16 | fileBytes[offset + 15] << 24},
        {"SizeOfOptionalHeader", fileBytes[offset + 16] | fileBytes[offset + 17] << 8},
        {"Characteristics", fileBytes[offset + 18] | fileBytes[offset + 19] << 8}
    };
}

void PEFileAnalyser::readOptionalHeader() {
    // Set offset
    int offset = dosHeader["e_lfanew"] + sizeof(uint32_t) + fileHeaderSize;

    optionalHeader = {
        {"Magic", fileBytes[offset] | fileBytes[offset + 1] << 8},
        {"MajorLinkerVersion", fileBytes[offset + 2]},
        {"MinorLinkerVersion", fileBytes[offset + 3]},
        {"SizeOfCode", fileBytes[offset + 4] | fileBytes[offset + 5] << 8 | fileBytes[offset + 6] << 16 | fileBytes[offset + 7] << 24},
        {"SizeOfInitializedData", fileBytes[offset + 8] | fileBytes[offset + 9] << 8 | fileBytes[offset + 10] << 16 | fileBytes[offset + 11] << 24},
        {"SizeOfUninitializedData", fileBytes[offset + 12] | fileBytes[offset + 13] << 8 | fileBytes[offset + 14] << 16 | fileBytes[offset + 15] << 24},
        {"AddressOfEntryPoint", fileBytes[offset + 16] | fileBytes[offset + 17] << 8 | fileBytes[offset + 18] << 16 | fileBytes[offset + 19] << 24},
        {"BaseOfCode", fileBytes[offset + 20] | fileBytes[offset + 21] << 8 | fileBytes[offset + 22] << 16 | fileBytes[offset + 23] << 24},
        {"BaseOfData", fileBytes[offset + 24] | fileBytes[offset + 25] << 8 | fileBytes[offset + 26] << 16 | fileBytes[offset + 27] << 24},
        {"ImageBase", fileBytes[offset + 28] | fileBytes[offset + 29] << 8 | fileBytes[offset + 30] << 16 | fileBytes[offset + 31] << 24},
        {"SectionAlignment", fileBytes[offset + 32] | fileBytes[offset + 33] << 8 | fileBytes[offset + 34] << 16 | fileBytes[offset + 35] << 24},
        {"FileAlignment", fileBytes[offset + 36] | fileBytes[offset + 37] << 8 | fileBytes[offset + 38] << 16 | fileBytes[offset + 39] << 24},
        {"MajorOperatingSystemVersion", fileBytes[offset + 40] | fileBytes[offset + 41] << 8},
        {"MinorOperatingSystemVersion", fileBytes[offset + 42] | fileBytes[offset + 43] << 8},
        {"MajorImageVersion", fileBytes[offset + 44] | fileBytes[offset + 45] << 8},
        {"MinorImageVersion", fileBytes[offset + 46] | fileBytes[offset + 47] << 8},
        {"MajorSubsystemVersion", fileBytes[offset + 48] | fileBytes[offset + 49] << 8},
        {"MinorSubsystemVersion", fileBytes[offset + 50] | fileBytes[offset + 51] << 8},
        {"Win32VersionValue", fileBytes[offset + 52] | fileBytes[offset + 53] << 8 | fileBytes[offset + 54] << 16 | fileBytes[offset + 55] << 24},
        {"SizeOfImage", fileBytes[offset + 56] | fileBytes[offset + 57] << 8 | fileBytes[offset + 58] << 16 | fileBytes[offset + 59] << 24},
        {"SizeOfHeaders", fileBytes[offset + 60] | fileBytes[offset + 61] << 8 | fileBytes[offset + 62] << 16 | fileBytes[offset + 63] << 24},
        {"CheckSum", fileBytes[offset + 64] | fileBytes[offset + 65] << 8 | fileBytes[offset + 66] << 16 | fileBytes[offset + 67] << 24},
        {"Subsystem", fileBytes[offset + 68] | fileBytes[offset + 69] << 8},
        {"DllCharacteristics", fileBytes[offset + 70] | fileBytes[offset + 71] << 8},
        {"SizeOfStackReserve", fileBytes[offset + 72] | fileBytes[offset + 73] << 8 | fileBytes[offset + 74] << 16 | fileBytes[offset + 75] << 24},
        {"SizeOfStackCommit", fileBytes[offset + 76] | fileBytes[offset + 77] << 8 | fileBytes[offset + 78] << 16 | fileBytes[offset + 79] << 24},
        {"SizeOfHeapReserve", fileBytes[offset + 80] | fileBytes[offset + 81] << 8 | fileBytes[offset + 82] << 16 | fileBytes[offset + 83] << 24},
        {"SizeOfHeapCommit", fileBytes[offset + 84] | fileBytes[offset + 85] << 8 | fileBytes[offset + 86] << 16 | fileBytes[offset + 87] << 24},
        {"LoaderFlags", fileBytes[offset + 88] | fileBytes[offset + 89] << 8 | fileBytes[offset + 90] << 16 | fileBytes[offset + 91] << 24},
        {"NumberOfRvaAndSizes", fileBytes[offset + 92] | fileBytes[offset + 93] << 8 | fileBytes[offset + 94] << 16 | fileBytes[offset + 95] << 24}
    };
}

void PEFileAnalyser::readSections() {
    // Set offset
    int offset = dosHeader["e_lfanew"] + sizeof(uint32_t) + fileHeaderSize + fileHeader["SizeOfOptionalHeader"];

    for (int i = 0; i < fileHeader["NumberOfSections"]; i++) {
        std::map<std::string, double> section;
        section["Name"] = fileBytes[offset] | fileBytes[offset + 1] << 8 | fileBytes[offset + 2] << 16 | fileBytes[offset + 3] << 24;
        section["VirtualSize"] = fileBytes[offset + 4] | fileBytes[offset + 5] << 8 | fileBytes[offset + 6] << 16 | fileBytes[offset + 7] << 24;
        section["VirtualAddress"] = fileBytes[offset + 8] | fileBytes[offset + 9] << 8 | fileBytes[offset + 10] << 16 | fileBytes[offset + 11] << 24;
        section["SizeOfRawData"] = fileBytes[offset + 12] | fileBytes[offset + 13] << 8 | fileBytes[offset + 14] << 16 | fileBytes[offset + 15] << 24;
        section["PointerToRawData"] = fileBytes[offset + 16] | fileBytes[offset + 17] << 8 | fileBytes[offset + 18] << 16 | fileBytes[offset + 19] << 24;
        section["PointerToRelocations"] = fileBytes[offset + 20] | fileBytes[offset + 21] << 8 | fileBytes[offset + 22] << 16 | fileBytes[offset + 23] << 24;
        section["PointerToLinenumbers"] = fileBytes[offset + 24] | fileBytes[offset + 25] << 8 | fileBytes[offset + 26] << 16 | fileBytes[offset + 27] << 24;
        section["NumberOfRelocations"] = fileBytes[offset + 28] | fileBytes[offset + 29] << 8;
        section["NumberOfLinenumbers"] = fileBytes[offset + 30] | fileBytes[offset + 31] << 8;
        section["Characteristics"] = fileBytes[offset + 32] | fileBytes[offset + 33] << 8 | fileBytes[offset + 34] << 16 | fileBytes[offset + 35] << 24;
        sections.push_back(section);
        offset += 40; // Next section
    }
}

void calculateStatistics(const std::vector<double>& values, double& max, double& min, double& mean) {
    max = *std::max_element(values.begin(), values.end());
    min = *std::min_element(values.begin(), values.end());
    mean = std::accumulate(values.begin(), values.end(), 0) / values.size();
}

void PEFileAnalyser::calculateSectionAttributes() {
    std::vector<double> sectionVirtualSize;
    std::vector<double> sectionVirtualAddress;
    std::vector<double> sectionSizeOfRawData;
    std::vector<double> sectionPointerToRawData;
    std::vector<double> sectionPointerToRelocations;
    std::vector<double> sectionPointerToLinenumbers;
    std::vector<double> sectionNumberOfRelocations;
    std::vector<double> sectionNumberOfLinenumbers;
    std::vector<double> sectionCharacteristics;
    std::vector<double> sectionEntropy;

    for (std::map<std::string, double>& section : sections) {
        sectionVirtualSize.push_back(section["VirtualSize"]);
        sectionVirtualAddress.push_back(section["VirtualAddress"]);
        sectionSizeOfRawData.push_back(section["SizeOfRawData"]);
        sectionPointerToRawData.push_back(section["PointerToRawData"]);
        sectionPointerToRelocations.push_back(section["PointerToRelocations"]);
        sectionPointerToLinenumbers.push_back(section["PointerToLinenumbers"]);
        sectionNumberOfRelocations.push_back(section["NumberOfRelocations"]);
        sectionNumberOfLinenumbers.push_back(section["NumberOfLinenumbers"]);
        sectionCharacteristics.push_back(section["Characteristics"]);

        // Calculate entropy of each section
        std::vector<uint8_t> sectionBytes(fileBytes.begin() + static_cast<size_t>(section["PointerToRawData"]), fileBytes.begin() + static_cast<size_t>(section["PointerToRawData"]) + static_cast<size_t>(section["SizeOfRawData"]));
        std::vector<int> counts(256, 0);
        for (const auto& byte : sectionBytes) {
            counts[byte]++;
        }
        double entropy = 0;
        for (const auto& count : counts) {
            if (count != 0) {
                double probability = static_cast<double>(count) / sectionBytes.size();
                entropy -= probability * std::log2(probability);
            }
        }
        sectionEntropy.push_back(entropy);
    }

    // Calculate max, min, and mean values for section attributes
    calculateStatistics(sectionVirtualSize, sectionData["MaxVirtualSize"], sectionData["MinVirtualSize"], sectionData["MeanVirtualSize"]);
    calculateStatistics(sectionVirtualAddress, sectionData["MaxVirtualAddress"], sectionData["MinVirtualAddress"], sectionData["MeanVirtualAddress"]);
    calculateStatistics(sectionSizeOfRawData, sectionData["MaxSizeOfRawData"], sectionData["MinSizeOfRawData"], sectionData["MeanSizeOfRawData"]);
    calculateStatistics(sectionPointerToRawData, sectionData["MaxPointerToRawData"], sectionData["MinPointerToRawData"], sectionData["MeanPointerToRawData"]);
    calculateStatistics(sectionPointerToRelocations, sectionData["MaxPointerToRelocations"], sectionData["MinPointerToRelocations"], sectionData["MeanPointerToRelocations"]);
    calculateStatistics(sectionPointerToLinenumbers, sectionData["MaxPointerToLinenumbers"], sectionData["MinPointerToLinenumbers"], sectionData["MeanPointerToLinenumbers"]);
    calculateStatistics(sectionNumberOfRelocations, sectionData["MaxNumberOfRelocations"], sectionData["MinNumberOfRelocations"], sectionData["MeanNumberOfRelocations"]);
    calculateStatistics(sectionNumberOfLinenumbers, sectionData["MaxNumberOfLinenumbers"], sectionData["MinNumberOfLinenumbers"], sectionData["MeanNumberOfLinenumbers"]);
    calculateStatistics(sectionCharacteristics, sectionData["MaxCharacteristics"], sectionData["MinCharacteristics"], sectionData["MeanCharacteristics"]);
    calculateStatistics(sectionEntropy, sectionData["MaxEntropy"], sectionData["MinEntropy"], sectionData["MeanEntropy"]);
}

void PEFileAnalyser::analyse(std::vector<std::string>& keys, std::vector<double>& values) {

    // Reads DOS Header and checks if it is valid
    if (!isValidPEFile()) {
        std::cerr << "File is not a valid PE file, Invalid DOS header" << std::endl;
        return;
    }

    readFileHeader();
    readOptionalHeader();
    readSections();
    calculateSectionAttributes();

    keys = this->keys;
    values = getValues();
}

bool PEFileAnalyser::isValidPEFile() {
    readDOSHeader();
    return dosHeader["e_magic"] == 0x5A4D;
}

std::vector<double> PEFileAnalyser::getValues() {
    // Merge maps into a single map
    std::map<std::string, double> mergedMap;

    mergedMap.insert(dosHeader.begin(), dosHeader.end());
    mergedMap.insert(fileHeader.begin(), fileHeader.end());
    mergedMap.insert(optionalHeader.begin(), optionalHeader.end());
    mergedMap.insert(sectionData.begin(), sectionData.end());

    // Get values in the order of keys
    std::vector<double> values;
    for (const auto& key : keys) {
        values.push_back(mergedMap[key]);
    }

    return values;
}

// Data Handling

// Get features from a single file
void fileAttr(const std::string& filePath, std::vector<std::string>& headers, std::vector<double>& features) {
    PEFileAnalyser file(filePath);
    file.analyse(headers, features);
}

// Load CSV file into a matrix
bool loadCSV(const std::string& filename, std::vector<std::vector<double>>& data, std::vector<int>& labels, std::vector<std::string>& header, std::string flagHeader, std::vector<std::string> ignoreColumns={}) {
    std::ifstream file(filename);
    if (!file.is_open()) {
        std::cerr << "Failed to open file: " << filename << std::endl;
        return false;
    }

    // Skip the first line (header)
    std::string line;
    std::getline(file, line);
    std::stringstream ss(line);
    std::string cell;

    std::vector<int> ignoreIndexes;
    int numIgnored = 0;
    int flagIndex = -1;
    int i = 0;

    while (std::getline(ss, cell, ',')) {
        if (std::find(ignoreColumns.begin(), ignoreColumns.end(), cell) != ignoreColumns.end()) {
            ignoreIndexes.push_back(i); // Add to ignore list
            numIgnored++;
        } else if (cell == flagHeader) {
            flagIndex = i - numIgnored; // Adjust for ignored columns
        } else {
            header.push_back(cell); // Add to header
        }

        i++;
    }

    // Flag header not found
    if (flagIndex == -1) {
        std::cerr << "Flag header not found: " << flagHeader << std::endl;
        return false;
    }

    // Read the rest of the file to get the data
    while (std::getline(file, line)) {
        std::vector<double> row;
        std::stringstream ss(line);
        std::string cell;
        int cellIndex = 0;
        while (std::getline(ss, cell, ',')) {
            if (std::find(ignoreIndexes.begin(), ignoreIndexes.end(), cellIndex) == ignoreIndexes.end()) {
                row.push_back(std::stod(cell));
            }
            cellIndex++;
        }

        if (!row.empty()) {
            labels.push_back(row[flagIndex]);
            row.erase(row.begin() + flagIndex);
            data.push_back(std::move(row));  // Use move semantics
        }
    }

    file.close();
    return true;
}