#include <string>
#include <vector>
#include <fstream>
#include <filesystem>
#include <numeric>
#include <random>
#include <unordered_set>
#include <sstream>
#include <iostream>
#include <algorithm>

typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned long DWORD;
typedef long LONG;
typedef unsigned long long QWORD;

#pragma pack(push, 1)

struct IMAGE_DOS_HEADER {
    WORD e_magic;
    WORD e_cblp;
    WORD e_cp;
    WORD e_crlc;
    WORD e_cparhdr;
    WORD e_minalloc;
    WORD e_maxalloc;
    WORD e_ss;
    WORD e_sp;
    WORD e_csum;
    WORD e_ip;
    WORD e_cs;
    WORD e_lfarlc;
    WORD e_ovno;
    WORD e_res[4];
    WORD e_oemid;
    WORD e_oeminfo;
    WORD e_res2[10];
    LONG e_lfanew;
};

struct IMAGE_FILE_HEADER {
    WORD  Machine;
    WORD  NumberOfSections;
    DWORD TimeDateStamp;
    DWORD PointerToSymbolTable;
    DWORD NumberOfSymbols;
    WORD  SizeOfOptionalHeader;
    WORD  Characteristics;
};

struct IMAGE_OPTIONAL_HEADER {
    WORD  Magic;
    BYTE  MajorLinkerVersion;
    BYTE  MinorLinkerVersion;
    DWORD SizeOfCode;
    DWORD SizeOfInitializedData;
    DWORD SizeOfUninitializedData;
    DWORD AddressOfEntryPoint;
    DWORD BaseOfCode;
    DWORD BaseOfData;
    DWORD ImageBase;
    DWORD SectionAlignment;
    DWORD FileAlignment;
    WORD  MajorOperatingSystemVersion;
    WORD  MinorOperatingSystemVersion;
    WORD  MajorImageVersion;
    WORD  MinorImageVersion;
    WORD  MajorSubsystemVersion;
    WORD  MinorSubsystemVersion;
    DWORD Win32VersionValue;
    DWORD SizeOfImage;
    DWORD SizeOfHeaders;
    DWORD CheckSum;
    WORD  Subsystem;
    WORD  DllCharacteristics;
    DWORD SizeOfStackReserve;
    DWORD SizeOfStackCommit;
    DWORD SizeOfHeapReserve;
    DWORD SizeOfHeapCommit;
    DWORD LoaderFlags;
    DWORD NumberOfRvaAndSizes;
};

struct IMAGE_SECTION_HEADER {
    char  Name[8];
    DWORD VirtualSize;
    DWORD VirtualAddress;
    DWORD SizeOfRawData;
    DWORD PointerToRawData;
    DWORD PointerToRelocations;
    DWORD PointerToLinenumbers;
    WORD  NumberOfRelocations;
    WORD  NumberOfLinenumbers;
    DWORD Characteristics;
};

struct IMAGE_SECTION_DATA {
    int MaxVirtualSize;
    int MinVirtualSize;
    int MeanVirtualSize;
    int MaxVirtualAddress;
    int MinVirtualAddress;
    int MeanVirtualAddress;
    int MaxSizeOfRawData;
    int MinSizeOfRawData;
    int MeanSizeOfRawData;
    int MaxPointerToRawData;
    int MinPointerToRawData;
    int MeanPointerToRawData;
    int MaxPointerToRelocations;
    int MinPointerToRelocations;
    int MeanPointerToRelocations;
    int MaxPointerToLinenumbers;
    int MinPointerToLinenumbers;
    int MeanPointerToLinenumbers;
    int MaxNumberOfRelocations;
    int MinNumberOfRelocations;
    int MeanNumberOfRelocations;
    int MaxNumberOfLinenumbers;
    int MinNumberOfLinenumbers;
    int MeanNumberOfLinenumbers;
    int MaxCharacteristics;
    int MinCharacteristics;
    int MeanCharacteristics;
    double MaxEntropy;
    double MinEntropy;
    double MeanEntropy;
};

#pragma pack(pop)

class PEFileAnalyser {
private:
    std::string filePath;
    std::ifstream file;
    std::vector<uint8_t> fileBytes;
    uint32_t fileSize;
    IMAGE_DOS_HEADER dosHeader;
    IMAGE_FILE_HEADER fileHeader;
    IMAGE_OPTIONAL_HEADER optionalHeader;
    std::vector<IMAGE_SECTION_HEADER> sections;
    IMAGE_SECTION_DATA sectionData;

    // Helper functions...
    std::vector<uint8_t> readFileBytes();
    void readDOSHeader();
    void readFileHeader();
    void readOptionalHeader();
    void readSections();
    void calculateSectionAttributes();
    std::vector<std::string> getKeys();
    std::vector<double> getValues();

public:
    PEFileAnalyser(const std::string& filePath);
    void analyse(std::vector<std::string>& keys, std::vector<double>& values);
    bool isValidPEFile();
};

PEFileAnalyser::PEFileAnalyser(const std::string& filePath) : filePath(filePath), file(filePath) {
    if (!file.is_open()) {
        std::cerr << "Failed to open file: " << filePath << std::endl;
        return;
    }

    file.seekg(0, std::ios::end);
    fileSize = file.tellg();
    file.seekg(0, std::ios::beg);

    fileBytes = readFileBytes();
}

std::vector<uint8_t> PEFileAnalyser::readFileBytes() {
    std::ifstream f(filePath, std::ios::binary);
    if (!f.is_open()) {
        std::cerr << "File is not open" << std::endl;
        return {};
    }

    // Read the file contents into a vector
    std::vector<uint8_t> fileData(fileSize);
    f.read(reinterpret_cast<char*>(fileData.data()), fileSize);

    return fileData;
}

void PEFileAnalyser::readDOSHeader() {
    // Move to DOS Header position
    file.seekg(0, std::ios::beg);
    file.read(reinterpret_cast<char*>(&dosHeader), sizeof(IMAGE_DOS_HEADER));
}

void PEFileAnalyser::readFileHeader() {
    // Move to File Header position
    file.seekg(dosHeader.e_lfanew + sizeof(uint32_t));
    file.read(reinterpret_cast<char*>(&fileHeader), sizeof(IMAGE_FILE_HEADER));
}

void PEFileAnalyser::readOptionalHeader() {
    // Move to Optional Header position
    file.seekg(dosHeader.e_lfanew + sizeof(uint32_t) + sizeof(IMAGE_FILE_HEADER));
    file.read(reinterpret_cast<char*>(&optionalHeader), sizeof(IMAGE_OPTIONAL_HEADER));
}

void PEFileAnalyser::readSections() {
    file.seekg(dosHeader.e_lfanew + sizeof(uint32_t) + sizeof(IMAGE_FILE_HEADER) + fileHeader.SizeOfOptionalHeader);

    for (int i = 0; i < fileHeader.NumberOfSections; ++i) {
        IMAGE_SECTION_HEADER section;
        file.read(reinterpret_cast<char*>(&section), sizeof(IMAGE_SECTION_HEADER));
        sections.push_back(section);
    }
}

void calculateStatistics(const std::vector<int>& values, int& maxVal, int& minVal, int& meanVal) {
        maxVal = *std::max_element(values.begin(), values.end());
        minVal = *std::min_element(values.begin(), values.end());
        meanVal = std::accumulate(values.begin(), values.end(), 0) / static_cast<double>(values.size());
    }

void PEFileAnalyser::calculateSectionAttributes() {
    std::vector<int> sectionVirtualSize;
    std::vector<int> sectionVirtualAddress;
    std::vector<int> sectionSizeOfRawData;
    std::vector<int> sectionPointerToRawData;
    std::vector<int> sectionPointerToRelocations;
    std::vector<int> sectionPointerToLinenumbers;
    std::vector<int> sectionNumberOfRelocations;
    std::vector<int> sectionNumberOfLinenumbers;
    std::vector<int> sectionCharacteristics;

    for (const IMAGE_SECTION_HEADER& section : sections) {
        sectionVirtualSize.push_back(section.VirtualSize);
        sectionVirtualAddress.push_back(section.VirtualAddress);
        sectionSizeOfRawData.push_back(section.SizeOfRawData);
        sectionPointerToRawData.push_back(section.PointerToRawData);
        sectionPointerToRelocations.push_back(section.PointerToRelocations);
        sectionPointerToLinenumbers.push_back(section.PointerToLinenumbers);
        sectionNumberOfRelocations.push_back(section.NumberOfRelocations);
        sectionNumberOfLinenumbers.push_back(section.NumberOfLinenumbers);
        sectionCharacteristics.push_back(section.Characteristics);
    }

    // Calculate max, min, and mean values for section attributes
    calculateStatistics(sectionVirtualSize, sectionData.MaxVirtualSize, sectionData.MinVirtualSize, sectionData.MeanVirtualSize);
    calculateStatistics(sectionVirtualAddress, sectionData.MaxVirtualAddress, sectionData.MinVirtualAddress, sectionData.MeanVirtualAddress);
    calculateStatistics(sectionSizeOfRawData, sectionData.MaxSizeOfRawData, sectionData.MinSizeOfRawData, sectionData.MeanSizeOfRawData);
    calculateStatistics(sectionPointerToRawData, sectionData.MaxPointerToRawData, sectionData.MinPointerToRawData, sectionData.MeanPointerToRawData);
    calculateStatistics(sectionPointerToRelocations, sectionData.MaxPointerToRelocations, sectionData.MinPointerToRelocations, sectionData.MeanPointerToRelocations);
    calculateStatistics(sectionPointerToLinenumbers, sectionData.MaxPointerToLinenumbers, sectionData.MinPointerToLinenumbers, sectionData.MeanPointerToLinenumbers);
    calculateStatistics(sectionNumberOfRelocations, sectionData.MaxNumberOfRelocations, sectionData.MinNumberOfRelocations, sectionData.MeanNumberOfRelocations);
    calculateStatistics(sectionNumberOfLinenumbers, sectionData.MaxNumberOfLinenumbers, sectionData.MinNumberOfLinenumbers, sectionData.MeanNumberOfLinenumbers);
    calculateStatistics(sectionCharacteristics, sectionData.MaxCharacteristics, sectionData.MinCharacteristics, sectionData.MeanCharacteristics);

    // Calculate entropy of each section
    std::vector<double> sectionEntropy;
    for (const IMAGE_SECTION_HEADER& section : sections) {
        std::vector<uint8_t> sectionBytes(fileBytes.begin() + section.PointerToRawData, fileBytes.begin() + section.PointerToRawData + section.SizeOfRawData);
        std::vector<int> counts(256, 0);
        for (const auto& byte : sectionBytes) {
            counts[byte]++;
        }
        double entropy = 0;
        for (const auto& count : counts) {
            if (count != 0) {
                double probability = static_cast<double>(count) / sectionBytes.size();
                entropy -= probability * std::log2(probability);
            }
        }
        sectionEntropy.push_back(entropy);
    }

    sectionData.MaxEntropy = *std::max_element(sectionEntropy.begin(), sectionEntropy.end());
    sectionData.MinEntropy = *std::min_element(sectionEntropy.begin(), sectionEntropy.end());
    sectionData.MeanEntropy = std::trunc(std::accumulate(sectionEntropy.begin(), sectionEntropy.end(), 0.0) / static_cast<double>(sectionEntropy.size()));
}

void PEFileAnalyser::analyse(std::vector<std::string>& keys, std::vector<double>& values) {

    // Reads DOS Header and checks if it is valid
    if (!isValidPEFile()) {
        std::cerr << "File is not a valid PE file, Invalid DOS header" << std::endl;
        return;
    }

    readFileHeader();
    readOptionalHeader();
    readSections();
    calculateSectionAttributes();

    keys = getKeys();
    values = getValues();

    file.close();
}

bool PEFileAnalyser::isValidPEFile() {
    if (!file.is_open()) {
        std::cerr << "File is not open" << std::endl;
        return false;
    }

    readDOSHeader();
    return dosHeader.e_magic == 0x5A4D;
}

std::vector<std::string> PEFileAnalyser::getKeys() {
    return {
        "e_magic",
        "e_cblp",
        "e_cp",
        "e_crlc",
        "e_cparhdr",
        "e_minalloc",
        "e_maxalloc",
        "e_ss",
        "e_sp",
        "e_csum",
        "e_ip",
        "e_cs",
        "e_lfarlc",
        "e_ovno",
        "e_oemid",
        "e_oeminfo",
        "e_lfanew",
        "Magic",
        "MajorLinkerVersion",
        "MinorLinkerVersion",
        "SizeOfCode",
        "SizeOfInitializedData",
        "SizeOfUninitializedData",
        "AddressOfEntryPoint",
        "BaseOfCode",
        "BaseOfData",
        "ImageBase",
        "SectionAlignment",
        "FileAlignment",
        "MajorOperatingSystemVersion",
        "MinorOperatingSystemVersion",
        "MajorImageVersion",
        "MinorImageVersion",
        "MajorSubsystemVersion",
        "MinorSubsystemVersion",
        "Win32VersionValue",
        "SizeOfImage",
        "SizeOfHeaders",
        "CheckSum",
        "Subsystem",
        "DllCharacteristics",
        "SizeOfStackReserve",
        "SizeOfStackCommit",
        "SizeOfHeapReserve",
        "SizeOfHeapCommit",
        "LoaderFlags",
        "NumberOfRvaAndSizes",
        "MaxVirtualSize",
        "MinVirtualSize",
        "MeanVirtualSize",
        "MaxVirtualAddress",
        "MinVirtualAddress",
        "MeanVirtualAddress",
        "MaxSizeOfRawData",
        "MinSizeOfRawData",
        "MeanSizeOfRawData",
        "MaxPointerToRawData",
        "MinPointerToRawData",
        "MeanPointerToRawData",
        "MaxPointerToRelocations",
        "MinPointerToRelocations",
        "MeanPointerToRelocations",
        "MaxPointerToLinenumbers",
        "MinPointerToLinenumbers",
        "MeanPointerToLinenumbers",
        "MaxNumberOfRelocations",
        "MinNumberOfRelocations",
        "MeanNumberOfRelocations",
        "MaxNumberOfLinenumbers",
        "MinNumberOfLinenumbers",
        "MeanNumberOfLinenumbers",
        "MaxCharacteristics",
        "MinCharacteristics",
        "MeanCharacteristics",
        "MaxEntropy",
        "MinEntropy",
        "MeanEntropy"
    };
}

std::vector<double> PEFileAnalyser::getValues() {
    return {
        static_cast<double>(dosHeader.e_magic),
        static_cast<double>(dosHeader.e_cblp),
        static_cast<double>(dosHeader.e_cp),
        static_cast<double>(dosHeader.e_crlc),
        static_cast<double>(dosHeader.e_cparhdr),
        static_cast<double>(dosHeader.e_minalloc),
        static_cast<double>(dosHeader.e_maxalloc),
        static_cast<double>(dosHeader.e_ss),
        static_cast<double>(dosHeader.e_sp),
        static_cast<double>(dosHeader.e_csum),
        static_cast<double>(dosHeader.e_ip),
        static_cast<double>(dosHeader.e_cs),
        static_cast<double>(dosHeader.e_lfarlc),
        static_cast<double>(dosHeader.e_ovno),
        static_cast<double>(dosHeader.e_oemid),
        static_cast<double>(dosHeader.e_oeminfo),
        static_cast<double>(dosHeader.e_lfanew),
        static_cast<double>(optionalHeader.Magic),
        static_cast<double>(optionalHeader.MajorLinkerVersion),
        static_cast<double>(optionalHeader.MinorLinkerVersion),
        static_cast<double>(optionalHeader.SizeOfCode),
        static_cast<double>(optionalHeader.SizeOfInitializedData),
        static_cast<double>(optionalHeader.SizeOfUninitializedData),
        static_cast<double>(optionalHeader.AddressOfEntryPoint),
        static_cast<double>(optionalHeader.BaseOfCode),
        static_cast<double>(optionalHeader.BaseOfData),
        static_cast<double>(optionalHeader.ImageBase),
        static_cast<double>(optionalHeader.SectionAlignment),
        static_cast<double>(optionalHeader.FileAlignment),
        static_cast<double>(optionalHeader.MajorOperatingSystemVersion),
        static_cast<double>(optionalHeader.MinorOperatingSystemVersion),
        static_cast<double>(optionalHeader.MajorImageVersion),
        static_cast<double>(optionalHeader.MinorImageVersion),
        static_cast<double>(optionalHeader.MajorSubsystemVersion),
        static_cast<double>(optionalHeader.MinorSubsystemVersion),
        static_cast<double>(optionalHeader.Win32VersionValue),
        static_cast<double>(optionalHeader.SizeOfImage),
        static_cast<double>(optionalHeader.SizeOfHeaders),
        static_cast<double>(optionalHeader.CheckSum),
        static_cast<double>(optionalHeader.Subsystem),
        static_cast<double>(optionalHeader.DllCharacteristics),
        static_cast<double>(optionalHeader.SizeOfStackReserve),
        static_cast<double>(optionalHeader.SizeOfStackCommit),
        static_cast<double>(optionalHeader.SizeOfHeapReserve),
        static_cast<double>(optionalHeader.SizeOfHeapCommit),
        static_cast<double>(optionalHeader.LoaderFlags),
        static_cast<double>(optionalHeader.NumberOfRvaAndSizes),
        static_cast<double>(sectionData.MaxVirtualSize),
        static_cast<double>(sectionData.MinVirtualSize),
        static_cast<double>(sectionData.MeanVirtualSize),
        static_cast<double>(sectionData.MaxVirtualAddress),
        static_cast<double>(sectionData.MinVirtualAddress),
        static_cast<double>(sectionData.MeanVirtualAddress),
        static_cast<double>(sectionData.MaxSizeOfRawData),
        static_cast<double>(sectionData.MinSizeOfRawData),
        static_cast<double>(sectionData.MeanSizeOfRawData),
        static_cast<double>(sectionData.MaxPointerToRawData),
        static_cast<double>(sectionData.MinPointerToRawData),
        static_cast<double>(sectionData.MeanPointerToRawData),
        static_cast<double>(sectionData.MaxPointerToRelocations),
        static_cast<double>(sectionData.MinPointerToRelocations),
        static_cast<double>(sectionData.MeanPointerToRelocations),
        static_cast<double>(sectionData.MaxPointerToLinenumbers),
        static_cast<double>(sectionData.MinPointerToLinenumbers),
        static_cast<double>(sectionData.MeanPointerToLinenumbers),
        static_cast<double>(sectionData.MaxNumberOfRelocations),
        static_cast<double>(sectionData.MinNumberOfRelocations),
        static_cast<double>(sectionData.MeanNumberOfRelocations),
        static_cast<double>(sectionData.MaxNumberOfLinenumbers),
        static_cast<double>(sectionData.MinNumberOfLinenumbers),
        static_cast<double>(sectionData.MeanNumberOfLinenumbers),
        static_cast<double>(sectionData.MaxCharacteristics),
        static_cast<double>(sectionData.MinCharacteristics),
        static_cast<double>(sectionData.MeanCharacteristics),
        static_cast<double>(sectionData.MaxEntropy),
        static_cast<double>(sectionData.MinEntropy),
        static_cast<double>(sectionData.MeanEntropy)
    };
}

// Data Handling

// Get features from a single file
void fileAttr(const std::string& filePath, std::vector<std::string>& headers, std::vector<double>& features) {
    PEFileAnalyser file(filePath);
    file.analyse(headers, features);
}

// Helper function to parse a line of CSV file and return the header as a vector of strings
std::vector<std::string> parseHeaderLine(const std::string& line) {
    std::vector<std::string> header;
    std::stringstream ss(line);
    std::string cell;
    while (std::getline(ss, cell, ',')) {
        header.push_back(cell);
    }
    return header;
}

// Helper function to parse a line of CSV file and return the values as a vector of doubles
std::vector<double> parseLine(const std::string& line, const std::vector<int>& ignoreIndexes) {
    std::vector<double> row;
    std::stringstream ss(line);
    std::string cell;
    int cellIndex = 0;
    while (std::getline(ss, cell, ',')) {
        if (std::find(ignoreIndexes.begin(), ignoreIndexes.end(), cellIndex) == ignoreIndexes.end()) {
            row.push_back(std::stod(cell));
        }
        cellIndex++;
    }
    return row;
}

// Load CSV file into a matrix
bool loadCSV(const std::string& filename, std::vector<std::vector<double>>& data, std::vector<int>& labels, std::vector<std::string>& header, std::string flagHeader, std::vector<std::string> ignoreColumns={}) {
    std::ifstream file(filename);
    if (!file.is_open()) {
        std::cerr << "Failed to open file: " << filename << std::endl;
        return false;
    }

    // Skip the first line (header)
    std::string line;
    std::getline(file, line);
    std::vector<std::string> tempHeader = parseHeaderLine(line);

    // Find the index of the flag header and ignore columns
    std::vector<int> ignoreIndexes;
    int numIgnored = 0;
    int flagIndex = -1;

    for (int i = 0; i < tempHeader.size(); i++) {
        for (const auto& ignoreColumn : ignoreColumns) {
            if (tempHeader[i] == ignoreColumn) {
                ignoreIndexes.push_back(i);
                numIgnored++;
                break;
            }
        }
        if (tempHeader[i] == flagHeader) {
            flagIndex = i - numIgnored;
            break;
        }
    }

    // Flag header not found
    if (flagIndex == -1) {
        std::cerr << "Flag header not found: " << flagHeader << std::endl;
        return false;
    }

    // Create header
    for (const auto& h : tempHeader) {
        if (std::find(ignoreColumns.begin(), ignoreColumns.end(), h) == ignoreColumns.end() && h != flagHeader) {
            header.push_back(h);
        }
    }

    // Read the rest of the file to get the data
    while (std::getline(file, line)) {
        std::vector<double> row = parseLine(line, ignoreIndexes);

        if (!row.empty()) {
            labels.push_back(row[flagIndex]);
            row.erase(row.begin() + flagIndex);
            row.pop_back();
            data.push_back(row);
        }
    }

    file.close();
    return true;
}